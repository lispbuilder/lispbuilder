<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html> 

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>LISPBUILDER-SDL - API Reference</title>
  <style type="text/css">
  pre { padding:5px; background-color:#e0e0e0 }
  h3, h4 { text-decoration: underline; }
  a { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:visited { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:hover { text-decoration: none; padding: 1px 1px 1px 1px; border: 1px solid #000000; } 
  a:focus { text-decoration: none; padding: 1px 2px 1px 2px; border: none; }
  a.none { text-decoration: none; padding: 0; }
  a.none:visited { text-decoration: none; padding: 0; } 
  a.none:hover { text-decoration: none; border: none; padding: 0; } 
  a.none:focus { text-decoration: none; border: none; padding: 0; } 
  a.noborder { text-decoration: none; padding: 0; } 
  a.noborder:visited { text-decoration: none; padding: 0; } 
  a.noborder:hover { text-decoration: none; border: none; padding: 0; } 
  a.noborder:focus { text-decoration: none; border: none; padding: 0; }  
  pre.none { padding:5px; background-color:#ffffff }
  </style>
</head>

<body bgcolor=white>

<h2> LISPBUILDER-SDL - API Reference</h2>

<blockquote>
<br>&nbsp;<br><h3><a name=abstract class=none>Abstract</a></h3>

The code comes with
a <a
href="http://www.opensource.org/licenses/bsd-license.php">BSD-style
license</a> so you can basically do with it whatever you want.

<p>
<font color=red>Download shortcut:</font> <a href="http://weitz.de/files/lispbuilder-sdl.tar.gz">http://weitz.de/files/lispbuilder-sdl.tar.gz</a>.
</blockquote>

<br>&nbsp;<br><h3><a class=none name="contents">Contents</a></h3>
<ol>
  <li><a href="#download">Download</a>
  <li><a href="#dictionary">The LISPBUILDER-SDL dictionary</a>
    <ol>
      <li><a href="#*black*"><code>*black*</code></a>
      <li><a href="#*blue*"><code>*blue*</code></a>
      <li><a href="#*cyan*"><code>*cyan*</code></a>
      <li><a href="#*default-color*"><code>*default-color*</code></a>
      <li><a href="#*default-display*"><code>*default-display*</code></a>
      <li><a href="#*default-font*"><code>*default-font*</code></a>
      <li><a href="#*default-font-path*"><code>*default-font-path*</code></a>
      <li><a href="#*default-position*"><code>*default-position*</code></a>
      <li><a href="#*default-rectangle*"><code>*default-rectangle*</code></a>
      <li><a href="#*default-simple-font*"><code>*default-simple-font*</code></a>
      <li><a href="#*default-surface*"><code>*default-surface*</code></a>
      <li><a href="#*external-init-on-startup*"><code>*external-init-on-startup*</code></a>
      <li><a href="#*external-quit-on-exit*"><code>*external-quit-on-exit*</code></a>
      <li><a href="#*font-10x20*"><code>*font-10x20*</code></a>
      <li><a href="#*font-5x7*"><code>*font-5x7*</code></a>
      <li><a href="#*font-5x8*"><code>*font-5x8*</code></a>
      <li><a href="#*font-6x10*"><code>*font-6x10*</code></a>
      <li><a href="#*font-6x12*"><code>*font-6x12*</code></a>
      <li><a href="#*font-6x13*"><code>*font-6x13*</code></a>
      <li><a href="#*font-6x13b*"><code>*font-6x13b*</code></a>
      <li><a href="#*font-6x13o*"><code>*font-6x13o*</code></a>
      <li><a href="#*font-6x9*"><code>*font-6x9*</code></a>
      <li><a href="#*font-7x13*"><code>*font-7x13*</code></a>
      <li><a href="#*font-7x13b*"><code>*font-7x13b*</code></a>
      <li><a href="#*font-7x13o*"><code>*font-7x13o*</code></a>
      <li><a href="#*font-7x14*"><code>*font-7x14*</code></a>
      <li><a href="#*font-7x14b*"><code>*font-7x14b*</code></a>
      <li><a href="#*font-8x13*"><code>*font-8x13*</code></a>
      <li><a href="#*font-8x13b*"><code>*font-8x13b*</code></a>
      <li><a href="#*font-8x13o*"><code>*font-8x13o*</code></a>
      <li><a href="#*font-8x8*"><code>*font-8x8*</code></a>
      <li><a href="#*font-9x15*"><code>*font-9x15*</code></a>
      <li><a href="#*font-9x15b*"><code>*font-9x15b*</code></a>
      <li><a href="#*font-9x18*"><code>*font-9x18*</code></a>
      <li><a href="#*font-9x18b*"><code>*font-9x18b*</code></a>
      <li><a href="#*green*"><code>*green*</code></a>
      <li><a href="#*magenta*"><code>*magenta*</code></a>
      <li><a href="#*opengl-context*"><code>*opengl-context*</code></a>
      <li><a href="#*red*"><code>*red*</code></a>
      <li><a href="#*sdl-initialized*"><code>*sdl-initialized*</code></a>
      <li><a href="#*simple-font-4x5*"><code>*simple-font-4x5*</code></a>
      <li><a href="#*white*"><code>*white*</code></a>
      <li><a href="#*yellow*"><code>*yellow*</code></a>
      <li><a href="#a"><code>a</code></a>
      <li><a href="#all-integers?"><code>all-integers?</code></a>
      <li><a href="#alpha"><code>alpha</code></a>
      <li><a href="#alpha-enabled-p"><code>alpha-enabled-p</code></a>
      <li><a href="#any-color-but-this"><code>any-color-but-this</code></a>
      <li><a href="#average-fps"><code>average-fps</code></a>
      <li><a href="#b"><code>b</code></a>
      <li><a href="#bit-depth"><code>bit-depth</code></a>
      <li><a href="#bitmap-font"><code>bitmap-font</code></a>
      <li><a href="#blit-surface"><code>blit-surface</code></a>
      <li><a href="#cached-surface"><code>cached-surface</code></a>
      <li><a href="#cast"><code>cast</code></a>
      <li><a href="#cast-all-to-int"><code>cast-all-to-int</code></a>
      <li><a href="#cast-to-int"><code>cast-to-int</code></a>
      <li><a href="#catmull-rom-spline"><code>catmull-rom-spline</code></a>
      <li><a href="#char-height"><code>char-height</code></a>
      <li><a href="#char-width"><code>char-width</code></a>
      <li><a href="#check-types"><code>check-types</code></a>
      <li><a href="#clear-cell"><code>clear-cell</code></a>
      <li><a href="#clear-clip-rect"><code>clear-clip-rect</code></a>
      <li><a href="#clear-color-key"><code>clear-color-key</code></a>
      <li><a href="#clear-display"><code>clear-display</code></a>
      <li><a href="#clip-rect"><code>clip-rect</code></a>
      <li><a href="#color"><code>color</code></a>
      <li><a href="#color"><code>color</code></a>
      <li><a href="#color-*"><code>color-*</code></a>
      <li><a href="#color-a"><code>color-a</code></a>
      <li><a href="#color-key"><code>color-key</code></a>
      <li><a href="#color-key-enabled-p"><code>color-key-enabled-p</code></a>
      <li><a href="#color="><code>color=</code></a>
      <li><a href="#convert-surface"><code>convert-surface</code></a>
      <li><a href="#convert-to-display-format"><code>convert-to-display-format</code></a>
      <li><a href="#copy-channel-to-alpha"><code>copy-channel-to-alpha</code></a>
      <li><a href="#copy-point"><code>copy-point</code></a>
      <li><a href="#copy-surface"><code>copy-surface</code></a>
      <li><a href="#create-list-if-not"><code>create-list-if-not</code></a>
      <li><a href="#create-path"><code>create-path</code></a>
      <li><a href="#create-rwops-from-file"><code>create-rwops-from-file</code></a>
      <li><a href="#create-simple-font-definition"><code>create-simple-font-definition</code></a>
      <li><a href="#create-surface"><code>create-surface</code></a>
      <li><a href="#disable-key-repeat"><code>disable-key-repeat</code></a>
      <li><a href="#display-surface"><code>display-surface</code></a>
      <li><a href="#distance"><code>distance</code></a>
      <li><a href="#distance-*"><code>distance-*</code></a>
      <li><a href="#draw-bezier"><code>draw-bezier</code></a>
      <li><a href="#draw-box"><code>draw-box</code></a>
      <li><a href="#draw-box-*"><code>draw-box-*</code></a>
      <li><a href="#draw-circle"><code>draw-circle</code></a>
      <li><a href="#draw-circle-*"><code>draw-circle-*</code></a>
      <li><a href="#draw-curve"><code>draw-curve</code></a>
      <li><a href="#draw-ellipse"><code>draw-ellipse</code></a>
      <li><a href="#draw-ellipse-*"><code>draw-ellipse-*</code></a>
      <li><a href="#draw-filled-circle"><code>draw-filled-circle</code></a>
      <li><a href="#draw-filled-circle-*"><code>draw-filled-circle-*</code></a>
      <li><a href="#draw-filled-ellipse"><code>draw-filled-ellipse</code></a>
      <li><a href="#draw-filled-ellipse-*"><code>draw-filled-ellipse-*</code></a>
      <li><a href="#draw-filled-pie"><code>draw-filled-pie</code></a>
      <li><a href="#draw-filled-pie-*"><code>draw-filled-pie-*</code></a>
      <li><a href="#draw-filled-polygon"><code>draw-filled-polygon</code></a>
      <li><a href="#draw-filled-trigon"><code>draw-filled-trigon</code></a>
      <li><a href="#draw-font"><code>draw-font</code></a>
      <li><a href="#draw-font"><code>draw-font</code></a>
      <li><a href="#draw-font-at"><code>draw-font-at</code></a>
      <li><a href="#draw-font-at-*"><code>draw-font-at-*</code></a>
      <li><a href="#draw-hline"><code>draw-hline</code></a>
      <li><a href="#draw-line"><code>draw-line</code></a>
      <li><a href="#draw-line-*"><code>draw-line-*</code></a>
      <li><a href="#draw-pie"><code>draw-pie</code></a>
      <li><a href="#draw-pie-*"><code>draw-pie-*</code></a>
      <li><a href="#draw-pixel"><code>draw-pixel</code></a>
      <li><a href="#draw-pixel-*"><code>draw-pixel-*</code></a>
      <li><a href="#draw-polygon"><code>draw-polygon</code></a>
      <li><a href="#draw-rectangle"><code>draw-rectangle</code></a>
      <li><a href="#draw-rectangle-*"><code>draw-rectangle-*</code></a>
      <li><a href="#draw-shape"><code>draw-shape</code></a>
      <li><a href="#draw-string-blended"><code>draw-string-blended</code></a>
      <li><a href="#draw-string-blended-*"><code>draw-string-blended-*</code></a>
      <li><a href="#draw-string-shaded"><code>draw-string-shaded</code></a>
      <li><a href="#draw-string-shaded-*"><code>draw-string-shaded-*</code></a>
      <li><a href="#draw-string-solid"><code>draw-string-solid</code></a>
      <li><a href="#draw-string-solid-*"><code>draw-string-solid-*</code></a>
      <li><a href="#draw-surface"><code>draw-surface</code></a>
      <li><a href="#draw-surface-at"><code>draw-surface-at</code></a>
      <li><a href="#draw-surface-at-*"><code>draw-surface-at-*</code></a>
      <li><a href="#draw-trigon"><code>draw-trigon</code></a>
      <li><a href="#draw-vline"><code>draw-vline</code></a>
      <li><a href="#enable-alpha"><code>enable-alpha</code></a>
      <li><a href="#enable-color-key"><code>enable-color-key</code></a>
      <li><a href="#enable-key-repeat"><code>enable-key-repeat</code></a>
      <li><a href="#enable-key-repeat-p"><code>enable-key-repeat-p</code></a>
      <li><a href="#enable-rle-accel"><code>enable-rle-accel</code></a>
      <li><a href="#enable-unicode"><code>enable-unicode</code></a>
      <li><a href="#enable-unicode-p"><code>enable-unicode-p</code></a>
      <li><a href="#fill-surface"><code>fill-surface</code></a>
      <li><a href="#fill-surface-*"><code>fill-surface-*</code></a>
      <li><a href="#flood-fill"><code>flood-fill</code></a>
      <li><a href="#flood-fill-*"><code>flood-fill-*</code></a>
      <li><a href="#flood-fill-stack"><code>flood-fill-stack</code></a>
      <li><a href="#flood-fill-stack-*"><code>flood-fill-stack-*</code></a>
      <li><a href="#fp"><code>fp</code></a>
      <li><a href="#frame-rate"><code>frame-rate</code></a>
      <li><a href="#free"><code>free</code></a>
      <li><a href="#free-cached-surface"><code>free-cached-surface</code></a>
      <li><a href="#g"><code>g</code></a>
      <li><a href="#get-clip-rect"><code>get-clip-rect</code></a>
      <li><a href="#get-font-ascent"><code>get-font-ascent</code></a>
      <li><a href="#get-font-descent"><code>get-font-descent</code></a>
      <li><a href="#get-font-face-family-name"><code>get-font-face-family-name</code></a>
      <li><a href="#get-font-face-style-name"><code>get-font-face-style-name</code></a>
      <li><a href="#get-font-faces"><code>get-font-faces</code></a>
      <li><a href="#get-font-height"><code>get-font-height</code></a>
      <li><a href="#get-font-line-skip"><code>get-font-line-skip</code></a>
      <li><a href="#get-font-size"><code>get-font-size</code></a>
      <li><a href="#get-font-style"><code>get-font-style</code></a>
      <li><a href="#get-glyph-metric"><code>get-glyph-metric</code></a>
      <li><a href="#get-key-state"><code>get-key-state</code></a>
      <li><a href="#get-native-window"><code>get-native-window</code></a>
      <li><a href="#get-point"><code>get-point</code></a>
      <li><a href="#get-position"><code>get-position</code></a>
      <li><a href="#get-rectangle"><code>get-rectangle</code></a>
      <li><a href="#get-surface-rect"><code>get-surface-rect</code></a>
      <li><a href="#handle-key-down"><code>handle-key-down</code></a>
      <li><a href="#handle-key-up"><code>handle-key-up</code></a>
      <li><a href="#height"><code>height</code></a>
      <li><a href="#image-p"><code>image-p</code></a>
      <li><a href="#image-type-of"><code>image-type-of</code></a>
      <li><a href="#init-sdl"><code>init-sdl</code></a>
      <li><a href="#init-sub-systems"><code>init-sub-systems</code></a>
      <li><a href="#initialise-default-font"><code>initialise-default-font</code></a>
      <li><a href="#initialise-font"><code>initialise-font</code></a>
      <li><a href="#initialise-input-util"><code>initialise-input-util</code></a>
      <li><a href="#initialize-on-startup"><code>initialize-on-startup</code></a>
      <li><a href="#initialized-sub-systems-p"><code>initialized-sub-systems-p</code></a>
      <li><a href="#is-font-face-fixed-width"><code>is-font-face-fixed-width</code></a>
      <li><a href="#is-valid-ptr"><code>is-valid-ptr</code></a>
      <li><a href="#key-held-p"><code>key-held-p</code></a>
      <li><a href="#key-held-time"><code>key-held-time</code></a>
      <li><a href="#key-pressed-p"><code>key-pressed-p</code></a>
      <li><a href="#key-repeat-delay"><code>key-repeat-delay</code></a>
      <li><a href="#key-repeat-interval"><code>key-repeat-interval</code></a>
      <li><a href="#key="><code>key=</code></a>
      <li><a href="#list-modes"><code>list-modes</code></a>
      <li><a href="#list-sub-systems"><code>list-sub-systems</code></a>
      <li><a href="#load-image"><code>load-image</code></a>
      <li><a href="#map-color"><code>map-color</code></a>
      <li><a href="#map-color-*"><code>map-color-*</code></a>
      <li><a href="#num-joysticks"><code>num-joysticks</code></a>
      <li><a href="#pack-color"><code>pack-color</code></a>
      <li><a href="#pixel-alpha-enabled-p"><code>pixel-alpha-enabled-p</code></a>
      <li><a href="#point"><code>point</code></a>
      <li><a href="#point-*"><code>point-*</code></a>
      <li><a href="#position-*"><code>position-*</code></a>
      <li><a href="#push-quit-event"><code>push-quit-event</code></a>
      <li><a href="#push-user-event"><code>push-user-event</code></a>
      <li><a href="#query-cursor"><code>query-cursor</code></a>
      <li><a href="#quit-input-util"><code>quit-input-util</code></a>
      <li><a href="#quit-on-exit"><code>quit-on-exit</code></a>
      <li><a href="#quit-sdl"><code>quit-sdl</code></a>
      <li><a href="#quit-sub-systems"><code>quit-sub-systems</code></a>
      <li><a href="#r"><code>r</code></a>
      <li><a href="#random+1"><code>random+1</code></a>
      <li><a href="#random-rectangle"><code>random-rectangle</code></a>
      <li><a href="#read-pixel"><code>read-pixel</code></a>
      <li><a href="#read-pixel-*"><code>read-pixel-*</code></a>
      <li><a href="#rectangle"><code>rectangle</code></a>
      <li><a href="#rectangle"><code>rectangle</code></a>
      <li><a href="#rectangle-*"><code>rectangle-*</code></a>
      <li><a href="#rectangle-from-edges"><code>rectangle-from-edges</code></a>
      <li><a href="#rectangle-from-edges-*"><code>rectangle-from-edges-*</code></a>
      <li><a href="#rectangle-from-midpoint-*"><code>rectangle-from-midpoint-*</code></a>
      <li><a href="#render-string-blended"><code>render-string-blended</code></a>
      <li><a href="#render-string-shaded"><code>render-string-shaded</code></a>
      <li><a href="#render-string-solid"><code>render-string-solid</code></a>
      <li><a href="#return-sub-systems-of-status"><code>return-sub-systems-of-status</code></a>
      <li><a href="#rle-accel-enabled-p"><code>rle-accel-enabled-p</code></a>
      <li><a href="#rotate-surface"><code>rotate-surface</code></a>
      <li><a href="#rotate-surface-xy"><code>rotate-surface-xy</code></a>
      <li><a href="#rwops"><code>rwops</code></a>
      <li><a href="#save-image"><code>save-image</code></a>
      <li><a href="#sdl-any-format"><code>sdl-any-format</code></a>
      <li><a href="#sdl-async-blit"><code>sdl-async-blit</code></a>
      <li><a href="#sdl-bitmap-font"><code>sdl-bitmap-font</code></a>
      <li><a href="#sdl-doublebuf"><code>sdl-doublebuf</code></a>
      <li><a href="#sdl-fullscreen"><code>sdl-fullscreen</code></a>
      <li><a href="#sdl-get-ticks"><code>sdl-get-ticks</code></a>
      <li><a href="#sdl-hw-accel"><code>sdl-hw-accel</code></a>
      <li><a href="#sdl-hw-palette"><code>sdl-hw-palette</code></a>
      <li><a href="#sdl-hw-surface"><code>sdl-hw-surface</code></a>
      <li><a href="#sdl-init-audio"><code>sdl-init-audio</code></a>
      <li><a href="#sdl-init-cdrom"><code>sdl-init-cdrom</code></a>
      <li><a href="#sdl-init-eventthread"><code>sdl-init-eventthread</code></a>
      <li><a href="#sdl-init-everything"><code>sdl-init-everything</code></a>
      <li><a href="#sdl-init-joystick"><code>sdl-init-joystick</code></a>
      <li><a href="#sdl-init-noparachute"><code>sdl-init-noparachute</code></a>
      <li><a href="#sdl-init-on-startup"><code>sdl-init-on-startup</code></a>
      <li><a href="#sdl-init-timer"><code>sdl-init-timer</code></a>
      <li><a href="#sdl-init-video"><code>sdl-init-video</code></a>
      <li><a href="#sdl-iyuv-overlay"><code>sdl-iyuv-overlay</code></a>
      <li><a href="#sdl-joystick-name"><code>sdl-joystick-name</code></a>
      <li><a href="#sdl-no-frame"><code>sdl-no-frame</code></a>
      <li><a href="#sdl-opengl"><code>sdl-opengl</code></a>
      <li><a href="#sdl-pre-alloc"><code>sdl-pre-alloc</code></a>
      <li><a href="#sdl-quit-on-exit"><code>sdl-quit-on-exit</code></a>
      <li><a href="#sdl-resizable"><code>sdl-resizable</code></a>
      <li><a href="#sdl-rle-accel"><code>sdl-rle-accel</code></a>
      <li><a href="#sdl-rle-accel-ok"><code>sdl-rle-accel-ok</code></a>
      <li><a href="#sdl-src-alpha"><code>sdl-src-alpha</code></a>
      <li><a href="#sdl-src-color-key"><code>sdl-src-color-key</code></a>
      <li><a href="#sdl-surface"><code>sdl-surface</code></a>
      <li><a href="#sdl-sw-surface"><code>sdl-sw-surface</code></a>
      <li><a href="#sdl-uyvy-overlay"><code>sdl-uyvy-overlay</code></a>
      <li><a href="#sdl-wm-grab-input"><code>sdl-wm-grab-input</code></a>
      <li><a href="#sdl-yuy2-overlay"><code>sdl-yuy2-overlay</code></a>
      <li><a href="#sdl-yv12-overlay"><code>sdl-yv12-overlay</code></a>
      <li><a href="#sdl-yvyu-overlay"><code>sdl-yvyu-overlay</code></a>
      <li><a href="#set-cell"><code>set-cell</code></a>
      <li><a href="#set-cell-*"><code>set-cell-*</code></a>
      <li><a href="#set-clip-rect"><code>set-clip-rect</code></a>
      <li><a href="#set-color"><code>set-color</code></a>
      <li><a href="#set-color-*"><code>set-color-*</code></a>
      <li><a href="#set-default-font"><code>set-default-font</code></a>
      <li><a href="#set-font-style"><code>set-font-style</code></a>
      <li><a href="#set-gl-attribute"><code>set-gl-attribute</code></a>
      <li><a href="#set-point"><code>set-point</code></a>
      <li><a href="#set-point-*"><code>set-point-*</code></a>
      <li><a href="#set-position"><code>set-position</code></a>
      <li><a href="#set-position-*"><code>set-position-*</code></a>
      <li><a href="#set-rectangle"><code>set-rectangle</code></a>
      <li><a href="#set-rectangle-*"><code>set-rectangle-*</code></a>
      <li><a href="#set-surface"><code>set-surface</code></a>
      <li><a href="#set-surface-*"><code>set-surface-*</code></a>
      <li><a href="#show-cursor"><code>show-cursor</code></a>
      <li><a href="#simple-font-definition"><code>simple-font-definition</code></a>
      <li><a href="#surface"><code>surface</code></a>
      <li><a href="#surface-info"><code>surface-info</code></a>
      <li><a href="#time-scale"><code>time-scale</code></a>
      <li><a href="#to-degree"><code>to-degree</code></a>
      <li><a href="#to-radian"><code>to-radian</code></a>
      <li><a href="#update-display"><code>update-display</code></a>
      <li><a href="#update-input-util"><code>update-input-util</code></a>
      <li><a href="#update-surface"><code>update-surface</code></a>
      <li><a href="#update-surface-*"><code>update-surface-*</code></a>
      <li><a href="#video-dimensions"><code>video-dimensions</code></a>
      <li><a href="#video-driver-name"><code>video-driver-name</code></a>
      <li><a href="#video-info"><code>video-info</code></a>
      <li><a href="#video-memory"><code>video-memory</code></a>
      <li><a href="#width"><code>width</code></a>
      <li><a href="#window"><code>window</code></a>
      <li><a href="#with-bezier"><code>with-bezier</code></a>
      <li><a href="#with-color"><code>with-color</code></a>
      <li><a href="#with-curve"><code>with-curve</code></a>
      <li><a href="#with-default-font"><code>with-default-font</code></a>
      <li><a href="#with-events"><code>with-events</code></a>
      <li><a href="#with-font"><code>with-font</code></a>
      <li><a href="#with-foreign-color-copy"><code>with-foreign-color-copy</code></a>
      <li><a href="#with-init"><code>with-init</code></a>
      <li><a href="#with-locked-surface"><code>with-locked-surface</code></a>
      <li><a href="#with-locked-surfaces"><code>with-locked-surfaces</code></a>
      <li><a href="#with-point"><code>with-point</code></a>
      <li><a href="#with-rectangle"><code>with-rectangle</code></a>
      <li><a href="#with-rectangles"><code>with-rectangles</code></a>
      <li><a href="#with-shape"><code>with-shape</code></a>
      <li><a href="#with-surface"><code>with-surface</code></a>
      <li><a href="#with-surface-slots"><code>with-surface-slots</code></a>
      <li><a href="#with-surfaces"><code>with-surfaces</code></a>
      <li><a href="#within-range"><code>within-range</code></a>
      <li><a href="#within-range-*"><code>within-range-*</code></a>
      <li><a href="#x"><code>x</code></a>
      <li><a href="#x2"><code>x2</code></a>
      <li><a href="#y"><code>y</code></a>
      <li><a href="#y2"><code>y2</code></a>
      <li><a href="#zoom-surface"><code>zoom-surface</code></a>
    </ol>
  <li><a href="#ack">Acknowledgements</a>
</ol>

<br>&nbsp;<br><h3><a class=none name="download">Download</a></h3>

LISPBUILDER-SDL together with this documentation can be downloaded from <a
href="http://weitz.de/files/lispbuilder-sdl.tar.gz">http://weitz.de/files/lispbuilder-sdl.tar.gz</a>. The
current version is 0.1.0.

<br>&nbsp;<br><h3><a class=none name="dictionary">The LISPBUILDER-SDL dictionary</a></h3>



<!-- Entry for *BLACK* -->

<p><br>[Special variable]<br><a class=none name='*black*'><b>*black*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> black. </p>

</blockquote>

<!-- End of entry for *BLACK* -->


<!-- Entry for *BLUE* -->

<p><br>[Special variable]<br><a class=none name='*blue*'><b>*blue*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> blue. </p>

</blockquote>

<!-- End of entry for *BLUE* -->


<!-- Entry for *CYAN* -->

<p><br>[Special variable]<br><a class=none name='*cyan*'><b>*cyan*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> cyan. </p>

</blockquote>

<!-- End of entry for *CYAN* -->


<!-- Entry for *DEFAULT-COLOR* -->

<p><br>[Special variable]<br><a class=none name='*default-color*'><b>*default-color*</b></a>
<blockquote><br>

<p>Functions that accept the <code>KEY</code>word parameter <code>COLOR</code> will most likely bind to the symbol <code>*DEFAULT-COLOR*</code> by default if <code>COLOR</code> is not specified. </p><p>A color is bound to <code>*DEFAULT-COLOR*</code> by the following macro: <a href="#with-color">WITH-COLOR</a>. </p><h5>Example</h5><pre><code>(DRAW-BOX A-BOX :SURFACE SDL:DEFAULT-DISPLAY* :COLOR SDL:*BLACK*)  
(DRAW-BOX B-BOX :SURFACE SDL:DEFAULT-DISPLAY* :COLOR SDL:*BLACK*)  
(DRAW-BOX C-BOX :SURFACE SDL:DEFAULT-DISPLAY* :COLOR SDL:*BLACK*) </code></pre><p>The above can be shortened by setting <code>*DEFAULT-COLOR*</code> to <code>*BLACK*</code>. </p><pre><code>(WITH-SURFACE (DISP SDL:*DEFAULT-DISPLAY*)  
  (WITH-COLOR (COL SDL:*BLACK*)  
    (DRAW-BOX A-BOX)  
    (DRAW-BOX B-BOX)  
    (DRAW-BOX C-BOX))) </code></pre>

</blockquote>

<!-- End of entry for *DEFAULT-COLOR* -->


<!-- Entry for *DEFAULT-DISPLAY* -->

<p><br>[Special variable]<br><a class=none name='*default-display*'><b>*default-display*</b></a>
<blockquote><br>

<p>The symbol <code>*DEFAULT-DISPLAY*</code> is bound to the current display surface <a href="#display-surface">DISPLAY-SURFACE</a>) by the function <a href="#WINDOW">WINDOW</a>). </p>

</blockquote>

<!-- End of entry for *DEFAULT-DISPLAY* -->


<!-- Entry for *DEFAULT-FONT* -->

<p><br>[Special variable]<br><a class=none name='*default-font*'><b>*default-font*</b></a>
<blockquote><br>

<p>Functions that accept the <code>KEY</code>word parameter <code>FONT</code> will most likely bind to the symbol <code>*DEFAULT-FONT*</code> by default if <code>FONT</code> is not specified. </p><p>A font is bound to <code>*DEFAULT-FONT*</code> by the following; <a href="#with-default-font">WITH-DEFAULT-FONT</a>, <a href="#with-font">WITH-FONT</a> and <a href="#initialise-default-font">INITIALISE-DEFAULT-FONT</a>. </p><h5>Example</h5><pre><code>(draw-string-solid-* &quot;draw string centered&quot; 100 100  
                      :justify :center :color sdl:*white* :font a-font)  
(draw-string-solid-* &quot;draw string left&quot; 100 100  
                      :justify :left :color sdl:*white* :font a-font)  
(draw-string-solid-* &quot;draw string right&quot; 100 100  
                      :justify :right :color sdl:*white* :font a-font) </code></pre><p>The above can be shortened by setting <code>*DEFAULT-FONT*</code> to <code>a-font</code>. </p><pre><code>(WITH-DEFAULT-FONT (a-font)  
  (WITH-COLOR (COL SDL:*WHITE*)  
    (DRAW-STRING-SOLID-* &quot;draw string centered&quot; 100 100 :JUSTIFY :CENTER)  
    (DRAW-STRING-SOLID-* &quot;draw string left&quot; 100 100 :JUSTIFY :LEFT)  
    (DRAW-STRING-SOLID-* &quot;draw string right&quot; 100 100 :JUSTIFY :RIGHT))) </code></pre>

</blockquote>

<!-- End of entry for *DEFAULT-FONT* -->


<!-- Entry for *DEFAULT-FONT-PATH* -->

<p><br>[Special variable]<br><a class=none name='*default-font-path*'><b>*default-font-path*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *DEFAULT-FONT-PATH* -->


<!-- Entry for *DEFAULT-POSITION* -->

<p><br>[Special variable]<br><a class=none name='*default-position*'><b>*default-position*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *DEFAULT-POSITION* -->


<!-- Entry for *DEFAULT-RECTANGLE* -->

<p><br>[Special variable]<br><a class=none name='*default-rectangle*'><b>*default-rectangle*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *DEFAULT-RECTANGLE* -->


<!-- Entry for *DEFAULT-SIMPLE-FONT* -->

<p><br>[Special variable]<br><a class=none name='*default-simple-font*'><b>*default-simple-font*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *DEFAULT-SIMPLE-FONT* -->


<!-- Entry for *DEFAULT-SURFACE* -->

<p><br>[Special variable]<br><a class=none name='*default-surface*'><b>*default-surface*</b></a>
<blockquote><br>

<p>Functions that accept the <code>KEY</code>word parameter <code>:SURFACE</code> will most likely bind to the symbol <code>*DEFAULT-SURFACE*</code> by default if <code>SURFACE</code> is not specified. </p><p>A surface is bound to <code>*DEFAULT-SURFACE*</code> by the following macros: <a href="#with-surface">WITH-SURFACE</a>, and <a href="#with-surfaces">WITH-SURFACES</a>. </p><h5>Example</h5><pre><code>(DRAW-SURFACE SURF-1 :SURFACE SDL:*DEFAULT-DISPLAY*)  
(DRAW-SURFACE SURF-2 :SURFACE SDL:*DEFAULT-DISPLAY*)  
(DRAW-SURFACE SURF-2 :SURFACE SDL:*DEFAULT-DISPLAY*) </code></pre><p>The above can be shortened using by setting the <code>*DEFAULT-SURFACE*</code> to the display surface. </p><pre><code>(WITH-SURFACE (DISP SDL:*DEFAULT-DISPLAY*)  
  (DRAW-SURFACE SURF-1)  
  (DRAW-SURFACE SURF-2)  
  (DRAW-SURFACE SURF-2)) </code></pre>

</blockquote>

<!-- End of entry for *DEFAULT-SURFACE* -->


<!-- Entry for *EXTERNAL-INIT-ON-STARTUP* -->

<p><br>[Special variable]<br><a class=none name='*external-init-on-startup*'><b>*external-init-on-startup*</b></a>
<blockquote><br>

<p>The list of functions that are called from <a href="#init-sdl">INIT-SDL</a>. </p>

</blockquote>

<!-- End of entry for *EXTERNAL-INIT-ON-STARTUP* -->


<!-- Entry for *EXTERNAL-QUIT-ON-EXIT* -->

<p><br>[Special variable]<br><a class=none name='*external-quit-on-exit*'><b>*external-quit-on-exit*</b></a>
<blockquote><br>

<p>The list of functions that are called from <a href="#quit-sdl">QUIT-SDL</a>. </p>

</blockquote>

<!-- End of entry for *EXTERNAL-QUIT-ON-EXIT* -->


<!-- Entry for *FONT-10X20* -->

<p><br>[Special variable]<br><a class=none name='*font-10x20*'><b>*font-10x20*</b></a>
<blockquote><br>

<p>Contains the font data for an 10x20 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-10X20* -->


<!-- Entry for *FONT-5X7* -->

<p><br>[Special variable]<br><a class=none name='*font-5x7*'><b>*font-5x7*</b></a>
<blockquote><br>

<p>Contains the font data for an 5x7 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-5X7* -->


<!-- Entry for *FONT-5X8* -->

<p><br>[Special variable]<br><a class=none name='*font-5x8*'><b>*font-5x8*</b></a>
<blockquote><br>

<p>Contains the font data for an 5x8 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-5X8* -->


<!-- Entry for *FONT-6X10* -->

<p><br>[Special variable]<br><a class=none name='*font-6x10*'><b>*font-6x10*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x10 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X10* -->


<!-- Entry for *FONT-6X12* -->

<p><br>[Special variable]<br><a class=none name='*font-6x12*'><b>*font-6x12*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x12 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X12* -->


<!-- Entry for *FONT-6X13* -->

<p><br>[Special variable]<br><a class=none name='*font-6x13*'><b>*font-6x13*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X13* -->


<!-- Entry for *FONT-6X13B* -->

<p><br>[Special variable]<br><a class=none name='*font-6x13b*'><b>*font-6x13b*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X13B* -->


<!-- Entry for *FONT-6X13O* -->

<p><br>[Special variable]<br><a class=none name='*font-6x13o*'><b>*font-6x13o*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X13O* -->


<!-- Entry for *FONT-6X9* -->

<p><br>[Special variable]<br><a class=none name='*font-6x9*'><b>*font-6x9*</b></a>
<blockquote><br>

<p>Contains the font data for an 6x9 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-6X9* -->


<!-- Entry for *FONT-7X13* -->

<p><br>[Special variable]<br><a class=none name='*font-7x13*'><b>*font-7x13*</b></a>
<blockquote><br>

<p>Contains the font data for an 7x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-7X13* -->


<!-- Entry for *FONT-7X13B* -->

<p><br>[Special variable]<br><a class=none name='*font-7x13b*'><b>*font-7x13b*</b></a>
<blockquote><br>

<p>Contains the font data for an 7x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-7X13B* -->


<!-- Entry for *FONT-7X13O* -->

<p><br>[Special variable]<br><a class=none name='*font-7x13o*'><b>*font-7x13o*</b></a>
<blockquote><br>

<p>Contains the font data for an 7x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-7X13O* -->


<!-- Entry for *FONT-7X14* -->

<p><br>[Special variable]<br><a class=none name='*font-7x14*'><b>*font-7x14*</b></a>
<blockquote><br>

<p>Contains the font data for an 7x14 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-7X14* -->


<!-- Entry for *FONT-7X14B* -->

<p><br>[Special variable]<br><a class=none name='*font-7x14b*'><b>*font-7x14b*</b></a>
<blockquote><br>

<p>Contains the font data for an 7x14 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-7X14B* -->


<!-- Entry for *FONT-8X13* -->

<p><br>[Special variable]<br><a class=none name='*font-8x13*'><b>*font-8x13*</b></a>
<blockquote><br>

<p>Contains the font data for an 8x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-8X13* -->


<!-- Entry for *FONT-8X13B* -->

<p><br>[Special variable]<br><a class=none name='*font-8x13b*'><b>*font-8x13b*</b></a>
<blockquote><br>

<p>Contains the font data for an 8x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-8X13B* -->


<!-- Entry for *FONT-8X13O* -->

<p><br>[Special variable]<br><a class=none name='*font-8x13o*'><b>*font-8x13o*</b></a>
<blockquote><br>

<p>Contains the font data for an 8x13 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-8X13O* -->


<!-- Entry for *FONT-8X8* -->

<p><br>[Special variable]<br><a class=none name='*font-8x8*'><b>*font-8x8*</b></a>
<blockquote><br>

<p>Contains the font data for an 8x8 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-8X8* -->


<!-- Entry for *FONT-9X15* -->

<p><br>[Special variable]<br><a class=none name='*font-9x15*'><b>*font-9x15*</b></a>
<blockquote><br>

<p>Contains the font data for an 9x15 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-9X15* -->


<!-- Entry for *FONT-9X15B* -->

<p><br>[Special variable]<br><a class=none name='*font-9x15b*'><b>*font-9x15b*</b></a>
<blockquote><br>

<p>Contains the font data for an 9x15 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-9X15B* -->


<!-- Entry for *FONT-9X18* -->

<p><br>[Special variable]<br><a class=none name='*font-9x18*'><b>*font-9x18*</b></a>
<blockquote><br>

<p>Contains the font data for an 9x18 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-9X18* -->


<!-- Entry for *FONT-9X18B* -->

<p><br>[Special variable]<br><a class=none name='*font-9x18b*'><b>*font-9x18b*</b></a>
<blockquote><br>

<p>Contains the font data for an 9x18 bitmap font. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for *FONT-9X18B* -->


<!-- Entry for *GREEN* -->

<p><br>[Special variable]<br><a class=none name='*green*'><b>*green*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> green. </p>

</blockquote>

<!-- End of entry for *GREEN* -->


<!-- Entry for *MAGENTA* -->

<p><br>[Special variable]<br><a class=none name='*magenta*'><b>*magenta*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> magenta. </p>

</blockquote>

<!-- End of entry for *MAGENTA* -->


<!-- Entry for *OPENGL-CONTEXT* -->

<p><br>[Special variable]<br><a class=none name='*opengl-context*'><b>*opengl-context*</b></a>
<blockquote><br>

<p>The symbol <code>*OPENGL-CONTEXT*</code> is <code>T</code> when an OpenGL display context is created, and <code>NIL</code> otherwise. <a href="#update-surface">UPDATE-SURFACE</a> will swap the <code>OPENGL</code> buffers when <code>*OPENGL-CONTEXT*</code> is <code>T</code>, and swap the <code>SDL</code> video buffers otherwise. </p>

</blockquote>

<!-- End of entry for *OPENGL-CONTEXT* -->


<!-- Entry for *RED* -->

<p><br>[Special variable]<br><a class=none name='*red*'><b>*red*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> red. </p>

</blockquote>

<!-- End of entry for *RED* -->


<!-- Entry for *SDL-INITIALIZED* -->

<p><br>[Special variable]<br><a class=none name='*sdl-initialized*'><b>*sdl-initialized*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *SDL-INITIALIZED* -->


<!-- Entry for *SIMPLE-FONT-4X5* -->

<p><br>[Special variable]<br><a class=none name='*simple-font-4x5*'><b>*simple-font-4x5*</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for *SIMPLE-FONT-4X5* -->


<!-- Entry for *WHITE* -->

<p><br>[Special variable]<br><a class=none name='*white*'><b>*white*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> white. </p>

</blockquote>

<!-- End of entry for *WHITE* -->


<!-- Entry for *YELLOW* -->

<p><br>[Special variable]<br><a class=none name='*yellow*'><b>*yellow*</b></a>
<blockquote><br>

<p><code>RGB</code> <a href="#color">COLOR</a> yellow. </p>

</blockquote>

<!-- End of entry for *YELLOW* -->


<!-- Entry for A -->

<p><br>[Generic accessor]<br><a class=none name='a'><b>a</b> <i>color</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>a</b> <i>color</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for A -->


<!-- Entry for A -->

<p><br>[Specialized accessor]<br><a class=none><b>a</b> <i>(color color-a)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>a</b> <i>(color color-a)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for A -->


<!-- Entry for A -->

<p><br>[Method]<br><a class=none><b>a</b> <i>(color color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for A -->


<!-- Entry for ALL-INTEGERS? -->

<p><br>[Macro]<br><a class=none name='all-integers?'><b>all-integers?</b> <i><tt>&amp;rest</tt> values</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if all values are <code>INTEGERS</code>. </p>

</blockquote>

<!-- End of entry for ALL-INTEGERS? -->


<!-- Entry for ALPHA -->

<p><br>[Generic accessor]<br><a class=none name='alpha'><b>alpha</b> <i>surface</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>alpha</b> <i>surface</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for ALPHA -->


<!-- Entry for ALPHA -->

<p><br>[Specialized accessor]<br><a class=none><b>alpha</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>alpha</b> <i>(surface sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for ALPHA -->


<!-- Entry for ALPHA-ENABLED-P -->

<p><br>[Generic accessor]<br><a class=none name='alpha-enabled-p'><b>alpha-enabled-p</b> <i>surface</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>alpha-enabled-p</b> <i>surface</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for ALPHA-ENABLED-P -->


<!-- Entry for ALPHA-ENABLED-P -->

<p><br>[Specialized accessor]<br><a class=none><b>alpha-enabled-p</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>alpha-enabled-p</b> <i>(surface sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for ALPHA-ENABLED-P -->


<!-- Entry for ANY-COLOR-BUT-THIS -->

<p><br>[Generic function]<br><a class=none name='any-color-but-this'><b>any-color-but-this</b> <i>color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new color that is different to <code>COLOR</code>. </p>

</blockquote>

<!-- End of entry for ANY-COLOR-BUT-THIS -->


<!-- Entry for ANY-COLOR-BUT-THIS -->

<p><br>[Method]<br><a class=none><b>any-color-but-this</b> <i>color</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for ANY-COLOR-BUT-THIS -->


<!-- Entry for AVERAGE-FPS -->

<p><br>[Function]<br><a class=none name='average-fps'><b>average-fps</b> <i><tt>&amp;optional</tt> fpsmanager</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the average frame rate of the event loop calculated over a sliding window of 100 frames. </p>

</blockquote>

<!-- End of entry for AVERAGE-FPS -->


<!-- Entry for B -->

<p><br>[Generic accessor]<br><a class=none name='b'><b>b</b> <i>color</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>b</b> <i>color</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for B -->


<!-- Entry for B -->

<p><br>[Specialized accessor]<br><a class=none><b>b</b> <i>(color color)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>b</b> <i>(color color)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for B -->


<!-- Entry for BIT-DEPTH -->

<p><br>[Function]<br><a class=none name='bit-depth'><b>bit-depth</b> <i><tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the number of bytes per pixel, or bpp, of <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for BIT-DEPTH -->


<!-- Entry for BITMAP-FONT -->

<p><br>[Standard class]<br><a class=none name='bitmap-font'><b>bitmap-font</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for BITMAP-FONT -->


<!-- Entry for BLIT-SURFACE -->

<p><br>[Function]<br><a class=none name='blit-surface'><b>blit-surface</b> <i>source <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Performs a fast blit of the <code>SOURCE</code> surface to the destination <code>SURFACE</code>. The area defined by the <code>SOURCE</code> cell is blitted to the area defined by the destination clipping rectangle. The blit function should not be called on a locked surface. The results of blitting operations vary greatly depending on whether a surface ALPHA channel is set on the source surface or not. The priorty of how color key and alpha attributes interact with surface blitting is as follows: </p><ul><li>source surface with <code>ALPHA</code> + <code>PIXEL-ALPHA</code>: Blit using per-pixel alpha only</li><li>source surface with <code>ALPHA</code> + <code>COLOR-KEY</code>: Blit using the colour key AND the per-surface alpha value</li><li>source surface with <code>ALPHA</code>: Blit using the colour key AND the per-surface alpha value</li><li>source surface with <code>COLOR-KEY</code>: Blit using the colour key</li><li>source surface: Blit using opaque rectangular blit</li></ul><p>An ALPHA channel has the following effect on blitting operations: </p><ul><li><em>RGBA to RGB</em> with <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The source is alpha-blended with the destination, using the alpha channel. <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> and the per-surface alpha are ignored. </li><li><em>RGBA to RGB</em> without <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The RGB data is copied from the source. The source alpha channel and the per-surface alpha value are ignored. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. </li><li><em>RGB to RGBA</em> with <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The source is alpha-blended with the destination using the per-surface alpha value. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. The alpha channel of the copied pixels is set to opaque. </li><li><em>RGB to RGBA</em> without <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The RGB data is copied from the source and the alpha value of the copied pixels is set to opaque. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. </li><li><em>RGBA to RGBA</em> with <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The source is alpha-blended with the destination using the source alpha channel. The alpha channel in the destination surface is left untouched. <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is ignored. </li><li><em>RGBA to RGBA</em> without <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The RGBA data is copied to the destination surface. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. </li><li><em>RGB to RGB</em> with <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The source is alpha-blended with the destination using the per-surface alpha value. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. </li><li><em>RGB to RGB</em> without <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>: The RGB data is copied from the source. If <a href="#color-key-enabled-p">COLOR-KEY-ENABLED-P</a> is set, only the pixels not matching the colorkey value are copied. </li></ul><p><em>Note</em>: <em>RGBA to RGBA</em> blits (with <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a> set) keep the alpha of the destination surface. This means that you cannot compose two arbitrary <em>RGBA</em> surfaces this way and get the result you would expect from &quot;overlaying&quot; them; the destination alpha will work as a mask. </p>

</blockquote>

<!-- End of entry for BLIT-SURFACE -->


<!-- Entry for CACHED-SURFACE -->

<p><br>[Generic accessor]<br><a class=none name='cached-surface'><b>cached-surface</b> <i>font</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>cached-surface</b> <i>font</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CACHED-SURFACE -->


<!-- Entry for CACHED-SURFACE -->

<p><br>[Specialized accessor]<br><a class=none><b>cached-surface</b> <i>(font font)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>cached-surface</b> <i>(font font)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CACHED-SURFACE -->


<!-- Entry for CAST -->

<p><br>[Macro]<br><a class=none name='cast'><b>cast</b> <i>type value</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Coerces the value <code>VALUE</code> to the type <code>TYPE</code>. </p>

</blockquote>

<!-- End of entry for CAST -->


<!-- Entry for CAST-ALL-TO-INT -->

<p><br>[Macro]<br><a class=none name='cast-all-to-int'><b>cast-all-to-int</b> <i><tt>&amp;rest</tt> values</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Casts the values in <code>REST</code> to <code>FIXNUM</code>s. </p>

</blockquote>

<!-- End of entry for CAST-ALL-TO-INT -->


<!-- Entry for CAST-TO-INT -->

<p><br>[Macro]<br><a class=none name='cast-to-int'><b>cast-to-int</b> <i>value</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Casts the value <code>VALUE</code> to a <code>FIXNUM</code>. </p>

</blockquote>

<!-- End of entry for CAST-TO-INT -->


<!-- Entry for CATMULL-ROM-SPLINE -->

<p><br>[Function]<br><a class=none name='catmull-rom-spline'><b>catmull-rom-spline</b> <i>val v0 v1 v2 v3</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CATMULL-ROM-SPLINE -->


<!-- Entry for CHAR-HEIGHT -->

<p><br>[Generic accessor]<br><a class=none name='char-height'><b>char-height</b> <i>bitmap-font-definition</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>char-height</b> <i>bitmap-font-definition</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-HEIGHT -->


<!-- Entry for CHAR-HEIGHT -->

<p><br>[Method]<br><a class=none><b>char-height</b> <i>(bitmap-font-definition bitmap-font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-HEIGHT -->


<!-- Entry for CHAR-HEIGHT -->

<p><br>[Specialized accessor]<br><a class=none><b>char-height</b> <i>(bitmap-font-definition bitmap-font-definition)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>char-height</b> <i>(bitmap-font-definition bitmap-font-definition)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-HEIGHT -->


<!-- Entry for CHAR-WIDTH -->

<p><br>[Generic accessor]<br><a class=none name='char-width'><b>char-width</b> <i>bitmap-font-definition</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>char-width</b> <i>bitmap-font-definition</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-WIDTH -->


<!-- Entry for CHAR-WIDTH -->

<p><br>[Method]<br><a class=none><b>char-width</b> <i>(bitmap-font-definition bitmap-font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-WIDTH -->


<!-- Entry for CHAR-WIDTH -->

<p><br>[Specialized accessor]<br><a class=none><b>char-width</b> <i>(bitmap-font-definition bitmap-font-definition)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>char-width</b> <i>(bitmap-font-definition bitmap-font-definition)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CHAR-WIDTH -->


<!-- Entry for CHECK-TYPES -->

<p><br>[Macro]<br><a class=none name='check-types'><b>check-types</b> <i>type <tt>&amp;rest</tt> rest</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Performs <code>CHECK-TYPE</code> on items in rest. </p>

</blockquote>

<!-- End of entry for CHECK-TYPES -->


<!-- Entry for CLEAR-CELL -->

<p><br>[Function]<br><a class=none name='clear-cell'><b>clear-cell</b> <i><tt>&amp;key</tt> surface index</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>CELL</code> at <code>INDEX</code> to the bounds of <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for CLEAR-CELL -->


<!-- Entry for CLEAR-CLIP-RECT -->

<p><br>[Function]<br><a class=none name='clear-clip-rect'><b>clear-clip-rect</b> <i><tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Removes the clipping <a href="#rectangle">RECTANGLE</a>. </p>

</blockquote>

<!-- End of entry for CLEAR-CLIP-RECT -->


<!-- Entry for CLEAR-COLOR-KEY -->

<p><br>[Function]<br><a class=none name='clear-color-key'><b>clear-color-key</b> <i><tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Disables the color key. </p>

</blockquote>

<!-- End of entry for CLEAR-COLOR-KEY -->


<!-- Entry for CLEAR-DISPLAY -->

<p><br>[Function]<br><a class=none name='clear-display'><b>clear-display</b> <i>color <tt>&amp;key</tt> surface update</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Fills the display <code>SURFACE</code> using color <code>COLOR</code>. <code>SURFACE</code> is bound to <code>*DEFAULT-DISPLAY*</code> if unspecified. The display is updated when <code>UPDATE</code> is <code>T</code>. </p>

</blockquote>

<!-- End of entry for CLEAR-DISPLAY -->


<!-- Entry for CLIP-RECT -->

<p><br>[Generic accessor]<br><a class=none name='clip-rect'><b>clip-rect</b> <i>surface</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>clip-rect</b> <i>surface</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CLIP-RECT -->


<!-- Entry for CLIP-RECT -->

<p><br>[Specialized accessor]<br><a class=none><b>clip-rect</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>clip-rect</b> <i>(surface sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CLIP-RECT -->


<!-- Entry for COLOR -->

<p><br>[Standard class]<br><a class=none name='color'><b>color</b></a>
<blockquote><br>

<p>A color containing <code>INTEGER</code> Red, Green and Blue components. Free using <a href="#free">FREE</a>. </p>

</blockquote>

<!-- End of entry for COLOR -->


<!-- Entry for COLOR -->

<p><br>[Function]<br><a class=none name='color'><b>color</b> <i><tt>&amp;key</tt> r g b a</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <code>RGB</code> <a href="#color">COLOR</a> from the specified <code>R</code>ed, <code>G</code>reen, and <code>B</code>lue components. Returns a new <code>RGBA</code> <a href="#color-a">COLOR-A</a> from the specified <code>R</code>ed, <code>G</code>reen, <code>B</code>lue, and <code>A</code>lpha components. </p>

</blockquote>

<!-- End of entry for COLOR -->


<!-- Entry for COLOR-* -->

<p><br>[Generic function]<br><a class=none name='color-*'><b>color-*</b> <i>color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>RGB/A</code> color components as a spread. <a href="#color-a">COLOR-A</a> returns <code>(VALUES R G B A)</code>. <a href="#color">COLOR</a> returns <code>(VALUES R G B)</code> </p>

</blockquote>

<!-- End of entry for COLOR-* -->


<!-- Entry for COLOR-* -->

<p><br>[Method]<br><a class=none><b>color-*</b> <i>(color color-a)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-* -->


<!-- Entry for COLOR-* -->

<p><br>[Method]<br><a class=none><b>color-*</b> <i>(color color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-* -->


<!-- Entry for COLOR-A -->

<p><br>[Standard class]<br><a class=none name='color-a'><b>color-a</b></a>
<blockquote><br>

<p>An color containing <code>INTEGER</code> Red, Green, Blue and Alpha components. Free using <a href="#free">FREE</a>. </p>

</blockquote>

<!-- End of entry for COLOR-A -->


<!-- Entry for COLOR-KEY -->

<p><br>[Generic accessor]<br><a class=none name='color-key'><b>color-key</b> <i>simple-font-definition</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>color-key</b> <i>simple-font-definition</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-KEY -->


<!-- Entry for COLOR-KEY -->

<p><br>[Specialized accessor]<br><a class=none><b>color-key</b> <i>(simple-font-definition simple-font-definition)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>color-key</b> <i>(simple-font-definition simple-font-definition)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-KEY -->


<!-- Entry for COLOR-KEY -->

<p><br>[Specialized accessor]<br><a class=none><b>color-key</b> <i>(simple-font-definition sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>color-key</b> <i>(simple-font-definition sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-KEY -->


<!-- Entry for COLOR-KEY-ENABLED-P -->

<p><br>[Generic accessor]<br><a class=none name='color-key-enabled-p'><b>color-key-enabled-p</b> <i>surface</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>color-key-enabled-p</b> <i>surface</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-KEY-ENABLED-P -->


<!-- Entry for COLOR-KEY-ENABLED-P -->

<p><br>[Specialized accessor]<br><a class=none><b>color-key-enabled-p</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>color-key-enabled-p</b> <i>(surface sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR-KEY-ENABLED-P -->


<!-- Entry for COLOR= -->

<p><br>[Generic function]<br><a class=none name='color='><b>color=</b> <i>color1 color2</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if the <code>RGB</code>&lt;-&gt;<code>RGB</code> or <code>RGBA</code>&lt;-&gt;<code>RGBA</code> color components in <code>COLOR1</code> and <code>COLOR2</code> match. Returns <code>NIL</code> otherwise. </p>

</blockquote>

<!-- End of entry for COLOR= -->


<!-- Entry for COLOR= -->

<p><br>[Method]<br><a class=none><b>color=</b> <i>(color1 color-a) (color2 color-a)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR= -->


<!-- Entry for COLOR= -->

<p><br>[Method]<br><a class=none><b>color=</b> <i>(color1 color) (color2 color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR= -->


<!-- Entry for COLOR= -->

<p><br>[Method]<br><a class=none><b>color=</b> <i>color1 color2</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COLOR= -->


<!-- Entry for CONVERT-SURFACE -->

<p><br>[Function]<br><a class=none name='convert-surface'><b>convert-surface</b> <i><tt>&amp;key</tt> surface to-surface enable-alpha enable-color-key free inherit type</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Converts <code>:SURFACE</code> and returns a new surface matching the pixel format and color of <code>:TO-SURFACE</code>. Calls <a href="#convert-to-display-format">CONVERT-TO-DISPLAY-FORMAT</a> if converting to the display format. </p><p>Use <code>:ENABLE-COLOR-KEY</code> or <code>:ENABLE-ALPHA</code> to take advantage of hardware colorkey or alpha blit acceleration. Enabling these flags once a surface is created will not necessarily utilize available harware acceleration if the surface was not initally created in video memory. </p><p>Will create the new surface in system menory when <code>TYPE</code> is <code>:SW</code>. Will attempt to create the new surface in video menory when <code>TYPE</code> is <code>:HW</code>, otherwise the surface is created in system memory if the combination of color key and alpha do not allow hardware acceleration. </p><p>The new surface will inherit the pixel, alpha and color key components of the source, <em>unless</em> <code>:INHERIT</code> is <code>NIL</code>. </p><p>Use <code>:FREE</code> to delete the source <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for CONVERT-SURFACE -->


<!-- Entry for CONVERT-TO-DISPLAY-FORMAT -->

<p><br>[Function]<br><a class=none name='convert-to-display-format'><b>convert-to-display-format</b> <i><tt>&amp;key</tt> surface enable-alpha enable-color-key pixel-alpha free inherit</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new surface matching the pixel format and color of the video frame buffer (<code>*display surface*), that is suitable for fast blitting. The new surface will inherit the pixel, alpha and color key components of the source, *unless* </code>:INHERIT<code> is </code>NIL`. </p><p>Use <code>:ENABLE-COLOR-KEY</code> or <code>:ENABLE-ALPHA</code> to take advantage of hardware colorkey or alpha blit acceleration. Enabling these flags once a surface is created will not necessarily utilize available harware acceleration if the surface was not initally created in video memory. </p><p>Use <code>:PIXEL-ALPHA</code> to enable the pixel alpha component (alpha mask of 0xFF) for the new surface. </p><p>Use <code>:FREE</code> to delete the source <code>SURFACE</code>. </p><p>Differences between <a href="#convert-to-display-format">CONVERT-TO-DISPLAY-FORMAT</a>, <a href="#convert-surface">CONVERT-SURFACE</a>, <a href="#copy-surface">COPY-SURFACE</a>, and <a href="#create-surface">CREATE-SURFACE</a>; </p><ul><li><p><a href="#convert-to-display-format">CONVERT-TO-DISPLAY-FORMAT</a> <strong> will always attempt to create a surface in video memory using hardware acceleration if key color and surface alpha are supported. </strong> A pixel alpha component can be specified. ** New surface is filled with old surface. </p></li><li><p><a href="#convert-surface">CONVERT-SURFACE</a> ** calls <a href="#convert-to-display-format">CONVERT-TO-DISPLAY-FORMAT</a> if converting a surface to the display format. <strong> paramatized option to create new surface in video or system memory. </strong> Pixel format and color match that of the source surface. ** New surface is filled with old surface. </p></li><li><a href="#copy-surface">COPY-SURFACE</a> <strong> paramatized option to create new surface in video or system memory. </strong> copies a portion or all of the source surface to a new destination surface <strong> A pixel alpha component can be specified. </strong> New surface can be filled with the old surface, or the color key or both. </li></ul>

</blockquote>

<!-- End of entry for CONVERT-TO-DISPLAY-FORMAT -->


<!-- Entry for COPY-CHANNEL-TO-ALPHA -->

<p><br>[Function]<br><a class=none name='copy-channel-to-alpha'><b>copy-channel-to-alpha</b> <i>destination source <tt>&amp;key</tt> channel</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for COPY-CHANNEL-TO-ALPHA -->


<!-- Entry for COPY-POINT -->

<p><br>[Function]<br><a class=none name='copy-point'><b>copy-point</b> <i>point</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a copy of the point <code>POINT</code>. </p>

</blockquote>

<!-- End of entry for COPY-POINT -->


<!-- Entry for COPY-SURFACE -->

<p><br>[Function]<br><a class=none name='copy-surface'><b>copy-surface</b> <i><tt>&amp;key</tt> cell cell-index surface color-key alpha pixel-alpha rle-accel type free inherit fill color-key-fill pixel-format</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a copy of <code>:SURFACE</code>. </p><p>Use <code>:COLOR-KEY</code> or <code>:ALPHA</code> to set the key color and surface alpha transparency. Hardware colorkey and alpha blit acceleration will be used if supported. </p><p>Will create the new surface in system menory when <code>TYPE</code> is <code>:SW</code>. Will attempt to create the new surface in video menory when <code>TYPE</code> is <code>:HW</code>, otherwise the surface is created in system memory if the combination of color key and alpha do not allow hardware acceleration. </p><p>The new surface will be filled with the old surface unless <code>:FILL</code> is <code>NIL</code>. The new surface will be filled with the color key of the old surface (if available) unless <code>:COLOR-KEY-FILL</code> is <code>NIL</code>. </p><p>The new surface will inherit the pixel, alpha and color key components of the source, <em>unless</em> <code>:INHERIT</code> is <code>NIL</code>. </p><p>Use <code>:FREE</code> to delete the source <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for COPY-SURFACE -->


<!-- Entry for CREATE-LIST-IF-NOT -->

<p><br>[Function]<br><a class=none name='create-list-if-not'><b>create-list-if-not</b> <i>var</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>If <code>VAR</code> is not already a list, then returns <code>(LIST VAR)</code>. </p>

</blockquote>

<!-- End of entry for CREATE-LIST-IF-NOT -->


<!-- Entry for CREATE-PATH -->

<p><br>[Function]<br><a class=none name='create-path'><b>create-path</b> <i>filename <tt>&amp;optional</tt> path</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates a new path from <code>FILENAME</code> and <code>PATH</code>. </p>

</blockquote>

<!-- End of entry for CREATE-PATH -->


<!-- Entry for CREATE-RWOPS-FROM-FILE -->

<p><br>[Function]<br><a class=none name='create-rwops-from-file'><b>create-rwops-from-file</b> <i>filename</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates and returns a new <code>RWOPS</code> object from the file at location <code>FILENAME</code>. </p>

</blockquote>

<!-- End of entry for CREATE-RWOPS-FROM-FILE -->


<!-- Entry for CREATE-SIMPLE-FONT-DEFINITION -->

<p><br>[Function]<br><a class=none name='create-simple-font-definition'><b>create-simple-font-definition</b> <i>width height char-map color-key filename <tt>&amp;key</tt> pad-x pad-y</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for CREATE-SIMPLE-FONT-DEFINITION -->


<!-- Entry for CREATE-SURFACE -->

<p><br>[Function]<br><a class=none name='create-surface'><b>create-surface</b> <i>width height <tt>&amp;key</tt> bpp type color-key color-key-at pixel-alpha alpha rle-accel x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates and returns a new <code>SURFACE</code> with the dimensions <code>WIDTH</code> and <code>HEIGHT</code>. </p><p><code>:COLOR-KEY</code> sets the color key of the surface and enables color-keying. </p><p><code>:ALPHA</code> sets the surface alpha transparency and enables alpha blending. This allows a pixel color of <code>RGB</code> with the surface <code>A</code>. </p><p><code>:PIXEL-ALPHA</code> enables a pixel alpha component (alpha mask of 0xFF) on the new surface. This allows a pixel color of <code>RGBA</code>. </p><p><code>:RLE-ACCEL</code> enables RLE blit acceleration. </p><p><code>:BPP</code> is the pixel depth of the surface, and my be 8, 16, 24 or 32. </p><p><code>:TYPE</code> attempts to create the <code>SURFACE</code> in video memory when <code>:HW</code>, and in system memory when <code>:SW</code> </p><p><code>:X</code> and <code>:Y</code> are the positions of the <code>SURFACE</code> in screen coordinates. </p>

</blockquote>

<!-- End of entry for CREATE-SURFACE -->


<!-- Entry for DISABLE-KEY-REPEAT -->

<p><br>[Function]<br><a class=none name='disable-key-repeat'><b>disable-key-repeat</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Disables keyboard repeat. </p>

</blockquote>

<!-- End of entry for DISABLE-KEY-REPEAT -->


<!-- Entry for DISPLAY-SURFACE -->

<p><br>[Standard class]<br><a class=none name='display-surface'><b>display-surface</b></a>
<blockquote><br>

<p>The current display surface. Can be accessed using <code>SDL:*DEFAULT-DISPLAY*</code>. </p>

</blockquote>

<!-- End of entry for DISPLAY-SURFACE -->


<!-- Entry for DISTANCE -->

<p><br>[Function]<br><a class=none name='distance'><b>distance</b> <i>p1 p2</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the distance between the <code>POINT</code>s <code>P1</code> and <code>P2</code>. </p>

</blockquote>

<!-- End of entry for DISTANCE -->


<!-- Entry for DISTANCE-* -->

<p><br>[Function]<br><a class=none name='distance-*'><b>distance-*</b> <i>x1 y1 x2 y2</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the distance between the coordinates <code>X1</code>, <code>Y1</code> and <code>X2</code>, <code>Y2</code>. </p>

</blockquote>

<!-- End of entry for DISTANCE-* -->


<!-- Entry for DRAW-BEZIER -->

<p><br>[Function]<br><a class=none name='draw-bezier'><b>draw-bezier</b> <i>vertices <tt>&amp;key</tt> clipping surface color segments style</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a bezier curve of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. The shape of the Bezier curve is defined by several control points. A control point is a vertex containing an X and Y coordinate pair. </p><h5>Parameters</h5><ul><li><code>:VERTICES</code> is a list of control points of <a href="#point">POINT</a>.</li><li><code>:STYLE</code> describes the line style used to draw the curve and may be one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. Use <code>:SOLID</code> to draw a single continuous line through the specified waypoints. Use <code>:DASH</code> to draw a line between alternate waypoint pairs. Use <code>:POINTS</code> to draw a single pixel at each waypoint. </li><li><code>:SEGMENTS</code> is the number of line segments used to draw the curve. The default is 20 segments if unspecified. The greater the number of segments, the smoother the curve. </li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the shape is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Example</h5><pre><code>(DRAW-BEZIER (LIST (SDL:POINT :X 60  :Y 40)  
                     (SDL:POINT :X 160 :Y 10)  
                     (SDL:POINT :X 170 :Y 150)  
                     (SDL:POINT :X 60 :Y 150))  
               :style :SOLID) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:STYLE</code> is ignored in <code>LISPBUILDER-SDL-GFX</code>.</li></ul>

</blockquote>

<!-- End of entry for DRAW-BEZIER -->


<!-- Entry for DRAW-BOX -->

<p><br>[Function]<br><a class=none name='draw-box'><b>draw-box</b> <i>rect <tt>&amp;key</tt> clipping surface color stroke-color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-box-*">DRAW-BOX-*</a>. </p><h5>Parameters</h5><ul><li><code>RECT</code> is <a href="#rectangle">RECTANGLE</a>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-BOX -->


<!-- Entry for DRAW-BOX-* -->

<p><br>[Function]<br><a class=none name='draw-box-*'><b>draw-box-*</b> <i>x y w h <tt>&amp;key</tt> clipping surface color stroke-color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a filled rectangle of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> are the <code>INTEGER</code> coordinates of the top-left corner of the rectangle.</li><li><code>W</code> and <code>H</code> are the width and height of the rectangle, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:STROKE-COLOR</code> when not <code>NIL</code> will draw a <code>1</code> pixel line of color <code>COLOR</code> around the perimiter of the box.</li><li><code>:ALPHA</code> when between <code>0</code> and <code>255</code> is used as the alpha transparency value when blitting the rectangle onto <code>SURFACE</code>. <em>Note:</em> An intermediate surface is created, the rectangle is drawn onto this intermediate surface and then this surface is blitted to <code>SURFACE</code>. </li><li><code>:CLIPPING</code> is <code>NIL</code> The default is <code>NIL</code> as the SDL library will perform the necessary clipping automatically.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-BOX-* -->


<!-- Entry for DRAW-CIRCLE -->

<p><br>[Function]<br><a class=none name='draw-circle'><b>draw-circle</b> <i>p1 r <tt>&amp;key</tt> surface color alpha aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-circle-*">DRAW-CIRCLE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates at the center of the circle.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:AA</code> ignored in <em>LISPBUILDER-SDL</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-CIRCLE -->


<!-- Entry for DRAW-CIRCLE-* -->

<p><br>[Function]<br><a class=none name='draw-circle-*'><b>draw-circle-*</b> <i>x0 y0 r <tt>&amp;key</tt> surface color alpha aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a circle circumference of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. Use <a href="#draw-filled-circle-*">DRAW-FILLED-CIRCLE-*</a> to draw a filled circle. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the center coordinate of the circle, of type <code>INTEGER</code>.</li><li><code>R</code> is the circle r, of type <code>INTEGER</code>.</li><li><code>:AA</code> determines if the line is to be drawn using antialiasing.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:ALPHA</code> when between <code>0</code> and <code>255</code> is used as the alpha transparency value when blitting the rectangle onto <code>SURFACE</code>. <em>Note:</em> An intermediate surface is created, the rectangle is drawn onto this intermediate surface and then this surface is blitted to <code>SURFACE</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:AA</code> ignored in <em>LISPBUILDER-SDL</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-CIRCLE-* -->


<!-- Entry for DRAW-CURVE -->

<p><br>[Function]<br><a class=none name='draw-curve'><b>draw-curve</b> <i>vertices <tt>&amp;key</tt> clipping surface color segments style</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a Cattmul-Rom spline of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. The shape of the curve is defined by waypoints. A waypoint is a vertex containing an X and Y coordinate pair. </p><h5>Parameters</h5><ul><li><code>VERTICES</code> is a list of waypoints or vetices for the spline, of <a href="#point">POINT</a></li><li><code>STYLE</code> describes the line style used to draw the curve and may be one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. Use <code>:SOLID</code> to draw a single continuous line through the specified waypoints. Use <code>:DASH</code> to draw a line between alternate waypoint pairs. Use <code>:POINTS</code> to draw a single pixel at each waypoint. </li><li><code>SEGMENTS</code> is the number of segments used to draw the Catmull-Rom spline. Default is 20 segments if unspecified. The greater the number of segments, the smoother the spline. </li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the shape is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Example</h5><pre><code>(DRAW-CURVE (LIST (SDL:POINT :X 60  :Y 40)  
    	  (SDL:POINT :X 160 :Y 10)  
	  (SDL:POINT :X 170 :Y 150)  
	  (SDL:POINT :X 60  :Y 150))) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-CURVE -->


<!-- Entry for DRAW-ELLIPSE -->

<p><br>[Function]<br><a class=none name='draw-ellipse'><b>draw-ellipse</b> <i>p1 rx ry <tt>&amp;key</tt> surface color aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-ellipse-*">DRAW-ELLIPSE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates at the center of the ellipse.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-ELLIPSE -->


<!-- Entry for DRAW-ELLIPSE-* -->

<p><br>[Function]<br><a class=none name='draw-ellipse-*'><b>draw-ellipse-*</b> <i>x y rx ry <tt>&amp;key</tt> surface color aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws an ellipse circumference of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a>. Use <a href="#draw-filled-ellipse-*">DRAW-FILLED-ELLIPSE-*</a> to draw a filled ellipse. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the center coordinate of the ellipse, of type <code>INTEGER</code>.</li><li><code>RX</code> and <code>RY</code> specify the ellipse radius, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-ELLIPSE-* -->


<!-- Entry for DRAW-FILLED-CIRCLE -->

<p><br>[Function]<br><a class=none name='draw-filled-circle'><b>draw-filled-circle</b> <i>p1 r <tt>&amp;key</tt> surface color stroke-color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-filled-circle-*">DRAW-FILLED-CIRCLE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates coordinate of the center of the filled circle.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-CIRCLE -->


<!-- Entry for DRAW-FILLED-CIRCLE-* -->

<p><br>[Function]<br><a class=none name='draw-filled-circle-*'><b>draw-filled-circle-*</b> <i>x0 y0 r <tt>&amp;key</tt> surface color stroke-color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a filled circle of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X0</code> and <code>Y0</code> specify the center coordinate of the circle, of type <code>INTEGER</code>.</li><li><code>R</code> is the circle radius, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:STROKE-COLOR</code> when not <code>NIL</code> will draw a <code>1</code> pixel line of color <code>COLOR</code> around the perimiter of the box.</li><li><code>:ALPHA</code> when between <code>0</code> and <code>255</code> is used as the alpha transparency value when blitting the rectangle onto <code>SURFACE</code>. <em>Note:</em> An intermediate surface is created, the rectangle is drawn onto this intermediate surface and then this surface is blitted to <code>SURFACE</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-CIRCLE-* -->


<!-- Entry for DRAW-FILLED-ELLIPSE -->

<p><br>[Function]<br><a class=none name='draw-filled-ellipse'><b>draw-filled-ellipse</b> <i>p1 rx ry <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-filled-ellipse-*">DRAW-FILLED-ELLIPSE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates at the center of the filled ellipse.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-ELLIPSE -->


<!-- Entry for DRAW-FILLED-ELLIPSE-* -->

<p><br>[Function]<br><a class=none name='draw-filled-ellipse-*'><b>draw-filled-ellipse-*</b> <i>x y rx ry <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a filled ellipse of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the center coordinate of the ellipse, of type <code>INTEGER</code>.</li><li><code>RX</code> and <code>RY</code> specify the ellipse radius, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-ELLIPSE-* -->


<!-- Entry for DRAW-FILLED-PIE -->

<p><br>[Function]<br><a class=none name='draw-filled-pie'><b>draw-filled-pie</b> <i>p1 rad start end <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-filled-pie-*">DRAW-FILLED-PIE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates at the center of the filled pie.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-PIE -->


<!-- Entry for DRAW-FILLED-PIE-* -->

<p><br>[Function]<br><a class=none name='draw-filled-pie-*'><b>draw-filled-pie-*</b> <i>x y rad start end <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a filled pie of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a> </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the center coordinate of the pie, of type <code>INTEGER</code>.</li><li><code>RAD</code> is the pie radius, of type <code>INTEGER</code>.</li><li><code>START</code> is the pie start, of type <code>INTEGER</code>.</li><li><code>END</code> is the pie end, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-PIE-* -->


<!-- Entry for DRAW-FILLED-POLYGON -->

<p><br>[Function]<br><a class=none name='draw-filled-polygon'><b>draw-filled-polygon</b> <i>vertices <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a filled polygon of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a> </p><h5>Parameters</h5><ul><li><code>VERTICES</code> is the list of vertices of type <code>SDL:POINT</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-POLYGON -->


<!-- Entry for DRAW-FILLED-TRIGON -->

<p><br>[Function]<br><a class=none name='draw-filled-trigon'><b>draw-filled-trigon</b> <i>p1 p2 p3 <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a filled trigon of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a> </p><h5>Parameters</h5><ul><li><code>P1</code>, <code>P2</code> and <code>P3</code> specify the vertices of the trigon, of type <code>SDL:POINT</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FILLED-TRIGON -->


<!-- Entry for DRAW-FONT -->

<p><br>[Generic function]<br><a class=none name='draw-font'><b>draw-font</b> <i><tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Blit the cached <a href="#surface">SURFACE</a> in <a href="#FONT">font</a> to the destination <code>SURFACE</code>. The cached surface is created during a previous call to any of the DRAW-STRING* functions. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FONT -->


<!-- Entry for DRAW-FONT -->

<p><br>[Function]<br><a class=none name='draw-font'><b>draw-font</b> <i><tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for DRAW-FONT -->


<!-- Entry for DRAW-FONT-AT -->

<p><br>[Generic function]<br><a class=none name='draw-font-at'><b>draw-font-at</b> <i>position <tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-font">DRAW-FONT</a>. The cached surface is rendered at <code>POSITION</code> <a href="#point">POINT</a>. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FONT-AT -->


<!-- Entry for DRAW-FONT-AT -->

<p><br>[Method]<br><a class=none><b>draw-font-at</b> <i>position <tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for DRAW-FONT-AT -->


<!-- Entry for DRAW-FONT-AT-* -->

<p><br>[Generic function]<br><a class=none name='draw-font-at-*'><b>draw-font-at-*</b> <i>x y <tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-font">DRAW-FONT</a>.  The cached surface is rendered at poisition <code>X</code> and <code>Y</code>. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-FONT-AT-* -->


<!-- Entry for DRAW-FONT-AT-* -->

<p><br>[Method]<br><a class=none><b>draw-font-at-*</b> <i>x y <tt>&amp;key</tt> font surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for DRAW-FONT-AT-* -->


<!-- Entry for DRAW-HLINE -->

<p><br>[Function]<br><a class=none name='draw-hline'><b>draw-hline</b> <i>x0 x1 y <tt>&amp;key</tt> surface color clipping template</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a horizontal line of <a href="#color">COLOR</a> from <code>X0</code> to <code>X1</code> through <code>Y</code> onto onto <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X0</code> and <code>X1</code> are the horizontal start and end points of the line, of type <code>INTEGER</code>.</li><li><code>Y</code> is the vertical <code>INTEGER</code> coordinate that the horizontal line must intersect.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> is <code>NIL</code> The default is <code>NIL</code> as the SDL library will perform the necessary clipping automatically.</li><li><code>:TEMPLATE</code> specifies an optional <a href="#rectangle">RECTANGLE</a> to fill the surface. Will not free <code>TEMPLATE</code>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-HLINE -->


<!-- Entry for DRAW-LINE -->

<p><br>[Function]<br><a class=none name='draw-line'><b>draw-line</b> <i>p1 p2 <tt>&amp;key</tt> surface color clipping aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-line-*">DRAW-LINE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> and <code>P2</code> are the start and end x/y co-ordinates of the line, of <code>POINT</code>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-LINE -->


<!-- Entry for DRAW-LINE-* -->

<p><br>[Function]<br><a class=none name='draw-line-*'><b>draw-line-*</b> <i>x0 y0 x1 y1 <tt>&amp;key</tt> surface color clipping aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a line of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X0</code> <code>Y0</code> are the start X/Y coordinates of the line, of <code>INTEGER</code>.</li><li><code>X1</code> <code>Y1</code> are the end X/Y coordinates of the line, of <code>INTEGER</code>.</li><li><code>:AA</code> determines if the line is to be drawn using antialiasing. <em>NOTE</em>: Supported only in <code>LISPBUILDER-SDL-GFX</code>, otherwise ignored.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the shape is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:AA</code> not supported in <em>LISPBUILDER-SDL</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-LINE-* -->


<!-- Entry for DRAW-PIE -->

<p><br>[Function]<br><a class=none name='draw-pie'><b>draw-pie</b> <i>p1 rad start end <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-pie-*">DRAW-PIE-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <a href="#point">POINT</a> coordinates at the center of the pie.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-PIE -->


<!-- Entry for DRAW-PIE-* -->

<p><br>[Function]<br><a class=none name='draw-pie-*'><b>draw-pie-*</b> <i>x y rad start end <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws a pie of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a>. Use <a href="#draw-filled-pie-*">DRAW-FILLED-PIE-*</a> to draw a filled pie. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the center coordinate of the pie, of type <code>INTEGER</code>.</li><li><code>RAD</code> is the pie radius, of type <code>INTEGER</code>.</li><li><code>START</code> is the pie start, of type <code>INTEGER</code>.</li><li><code>END</code> is the pie end, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-PIE-* -->


<!-- Entry for DRAW-PIXEL -->

<p><br>[Function]<br><a class=none name='draw-pixel'><b>draw-pixel</b> <i>point <tt>&amp;key</tt> clipping surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-pixel-*">DRAW-PIXEL-*</a>. </p><h5>Parameters</h5><ul><li><code>POINT</code> is the <a href="#point">POINT</a> coordinates of the pixel.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-PIXEL -->


<!-- Entry for DRAW-PIXEL-* -->

<p><br>[Function]<br><a class=none name='draw-pixel-*'><b>draw-pixel-*</b> <i>x y <tt>&amp;key</tt> clipping surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a single pixel of <a href="#color">COLOR</a> to the <a href="#surface">SURFACE</a> at the specified <code>X</code> and <code>Y</code> coordiates. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the coordinates of the pixel, and are of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the pixel is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-PIXEL-* -->


<!-- Entry for DRAW-POLYGON -->

<p><br>[Function]<br><a class=none name='draw-polygon'><b>draw-polygon</b> <i>vertices <tt>&amp;key</tt> surface color clipping aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw the circumference of a polygon of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a> using the vertices in <code>POINTS</code>. Use <a href="#draw-filled-polygon-*">DRAW-FILLED-POLYGON-*</a> to draw a filled polygon. </p><h5>Parameters</h5><ul><li><code>:POINTS</code> is the list of vertices for the polygon. <code>POINTS</code> is a list of <code>POINT</code>s.</li><li><code>:AA</code> determines if the line is to be drawn using antialiasing.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the pixel is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:AA</code> ignored in <em>LISPBUILDER-SDL</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-POLYGON -->


<!-- Entry for DRAW-RECTANGLE -->

<p><br>[Function]<br><a class=none name='draw-rectangle'><b>draw-rectangle</b> <i>rect <tt>&amp;key</tt> clipping surface color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-rectangle-*">DRAW-RECTANGLE-*</a>. </p><h5>Parameters</h5><ul><li><code>RECT</code> is <a href="#rectangle">RECTANGLE</a>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-RECTANGLE -->


<!-- Entry for DRAW-RECTANGLE-* -->

<p><br>[Function]<br><a class=none name='draw-rectangle-*'><b>draw-rectangle-*</b> <i>x y w h <tt>&amp;key</tt> clipping surface color alpha</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a rectangle outline of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> are the <code>INTEGER</code> coordinates of the top-left corner of the rectangle.</li><li><code>W</code> and <code>H</code> are the width and height of the rectangle, of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:ALPHA</code> when between <code>0</code> and <code>255</code> is used as the alpha transparency value when blitting the rectangle onto <code>SURFACE</code>. <em>Note:</em> An intermediate surface is created, the rectangle is drawn onto this intermediate surface and then this surface is blitted to <code>SURFACE</code>. </li><li><code>:CLIPPING</code> is <code>NIL</code> The default is <code>NIL</code> as the SDL library will perform the necessary clipping automatically.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-RECTANGLE-* -->


<!-- Entry for DRAW-SHAPE -->

<p><br>[Function]<br><a class=none name='draw-shape'><b>draw-shape</b> <i>vertices <tt>&amp;key</tt> clipping surface color style</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a polygon of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a> using <code>VERTICES</code>. </p><h5>Parameters</h5><ul><li><code>VERTICES</code> is a list of vertices, of <code>POINT</code></li><li><code>STYLE</code> describes the line style used to draw the polygon and may be one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. Use <code>:SOLID</code> to draw a single continuous line through the specified waypoints. Use <code>:DASH</code> to draw a line between alternate waypoint pairs. Use <code>:POINTS</code> to draw a single pixel at each waypoint. </li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the shape is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Example</h5><pre><code>(DRAW-SHAPE (LIST (SDL:POINT :X 60  :Y 40)  
	    (SDL:POINT :X 160 :Y 10)  
	    (SDL:POINT :X 170 :Y 150)  
	    (SDL:POINT :X 60  :Y 150))) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-SHAPE -->


<!-- Entry for DRAW-STRING-BLENDED -->

<p><br>[Function]<br><a class=none name='draw-string-blended'><b>draw-string-blended</b> <i>string p1 <tt>&amp;key</tt> justify surface font color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-string-blended-*">DRAW-STRING-BLENDED-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <code>X</code> and <code>X</code> coordinates to render the text, of type <code>POINT</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-BLENDED -->


<!-- Entry for DRAW-STRING-BLENDED-* -->

<p><br>[Function]<br><a class=none name='draw-string-blended-*'><b>draw-string-blended-*</b> <i>string x y <tt>&amp;key</tt> justify surface font color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw text <code>STRING</code> at location <code>X</code> <code>Y</code> using font <code>FONT</code> with color <code>COLOR</code> onto surface <code>SURFACE</code>. The text is keyed onto <code>SURFACE</code>. </p><h5>Parameters</h5><ul><li><code>STRING</code> is the text to render.</li><li><code>X</code> and <code>Y</code> are the <code>X</code> and <code>Y</code> position coordinates, as <code>INTEGERS</code>.</li><li><code>FONT</code> is the font face used to render the string. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified.</li><li><code>SURFACE</code> is the target surface, of type <code>SDL-SURFACE</code>. Bound to <code>*DEFAULT-SURFACE*</code> if unspecified.</li><li><code>COLOR</code> color is the text color, of type <code>COLOR</code>.</li></ul><h5>Returns</h5><ul><li>Returns the surface <code>SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(DRAW-STRING-SOLID-* &quot;Hello World!&quot; 0 0 :SURFACE A-SURFACE :COLOR A-COLOR) </code></pre><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-BLENDED-* -->


<!-- Entry for DRAW-STRING-SHADED -->

<p><br>[Function]<br><a class=none name='draw-string-shaded'><b>draw-string-shaded</b> <i>string p1 fg-color bg-color <tt>&amp;key</tt> justify surface font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-string-shaded-*">DRAW-STRING-SHADED-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <code>X</code> and <code>Y</code> coordinates to render the text, of type <code>SDL:POINT</code>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-SHADED -->


<!-- Entry for DRAW-STRING-SHADED-* -->

<p><br>[Function]<br><a class=none name='draw-string-shaded-*'><b>draw-string-shaded-*</b> <i>string x y fg-color bg-color <tt>&amp;key</tt> justify surface font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw text <code>STRING</code> at location <code>X</code> <code>Y</code> using font <code>FONT</code> with text color <code>FG-COLOR</code> and background color <code>BG-COLOR</code> onto surface <code>SURFACE</code>. The surface background is filled with <code>BG-COLOR</code> so the surface cannot be keyed over other surfaces. </p><ul><li><code>STRING</code> is the text to render.</li><li><code>X</code> and <code>Y</code> are the <code>X</code> and <code>Y</code> coordinates, as <code>INTEGERS</code>.</li><li><code>FG-COLOR</code> color is the text color, of type <code>COLOR</code></li><li><code>BG-COLOR</code> color is the background color used to fill the surface <code>SURFACE</code>, of type <code>COLOR</code></li><li><code>FONT</code> is the font face used to render the text. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified.</li><li><code>SURFACE</code> is the target surface, of type <code>SDL-SURFACE</code>. Bound to <code>*DEFAULT-SURFACE*</code> if unspecified.</li></ul><h5>Returns</h5><ul><li>Returns the surface <code>SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(DRAW-STRING-SHADED-* &quot;Hello World!&quot; 0 0 F-COLOR B-COLOR :SURFACE A-SURFACE) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-SHADED-* -->


<!-- Entry for DRAW-STRING-SOLID -->

<p><br>[Function]<br><a class=none name='draw-string-solid'><b>draw-string-solid</b> <i>string p1 <tt>&amp;key</tt> justify surface font color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#draw-string-solid-*">DRAW-STRING-SOLID-*</a>. </p><h5>Parameters</h5><ul><li><code>P1</code> is the <code>X</code> and <code>X</code> coordinates to render the text, of type <code>POINT</code>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-SOLID -->


<!-- Entry for DRAW-STRING-SOLID-* -->

<p><br>[Function]<br><a class=none name='draw-string-solid-*'><b>draw-string-solid-*</b> <i>string x y <tt>&amp;key</tt> justify surface font color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw text <code>STRING</code> at location <code>X</code> <code>Y</code> using font <code>FONT</code> with color <code>COLOR</code> onto surface <code>SURFACE</code>. The text is keyed onto <code>SURFACE</code>. </p><h5>Parameters</h5><ul><li><code>STRING</code> is the text to render.</li><li><code>X</code> and <code>Y</code> are the <code>X</code> and <code>Y</code> position coordinates, as <code>INTEGERS</code>.</li><li><code>FONT</code> is the font face used to render the string. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified.</li><li><code>SURFACE</code> is the target surface, of type <code>SDL-SURFACE</code>. Bound to <code>*DEFAULT-SURFACE*</code> if unspecified.</li><li><code>COLOR</code> color is the text color, of type <code>COLOR</code>.</li></ul><h5>Returns</h5><ul><li>Returns the surface <code>SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(DRAW-STRING-SOLID-* &quot;Hello World!&quot; 0 0 :SURFACE A-SURFACE :COLOR A-COLOR) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-STRING-SOLID-* -->


<!-- Entry for DRAW-SURFACE -->

<p><br>[Function]<br><a class=none name='draw-surface'><b>draw-surface</b> <i>src <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#blit-surface">BLIT-SURFACE</a> </p>

</blockquote>

<!-- End of entry for DRAW-SURFACE -->


<!-- Entry for DRAW-SURFACE-AT -->

<p><br>[Function]<br><a class=none name='draw-surface-at'><b>draw-surface-at</b> <i>src point <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws the source surface to the destination surface at position POINT.  See <a href="#blit-surface">BLIT-SURFACE</a>. </p>

</blockquote>

<!-- End of entry for DRAW-SURFACE-AT -->


<!-- Entry for DRAW-SURFACE-AT-* -->

<p><br>[Function]<br><a class=none name='draw-surface-at-*'><b>draw-surface-at-*</b> <i>src x y <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draws the source surface to the destination surface at position X and Y.  See <a href="#blit-surface">BLIT-SURFACE</a> </p>

</blockquote>

<!-- End of entry for DRAW-SURFACE-AT-* -->


<!-- Entry for DRAW-TRIGON -->

<p><br>[Function]<br><a class=none name='draw-trigon'><b>draw-trigon</b> <i>p1 p2 p3 <tt>&amp;key</tt> surface color clipping aa</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw the outline of a trigon or triangle, of <a href="#color">COLOR</a> to <a href="#surface">SURFACE</a>. Use <a href="#draw-filled-trigon-*">DRAW-FILLED-TRIGON-*</a> to draw a filled trigon. </p><h5>Parameters</h5><ul><li><code>P1</code>, <code>P2</code> and <code>P3</code> specify the vertices of the trigon, of type <code>SDL:POINT</code>.</li><li><code>:AA</code> determines if the line is to be drawn using antialiasing.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the pixel is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><code>:AA</code> ignored in <em>LISPBUILDER-SDL</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-TRIGON -->


<!-- Entry for DRAW-VLINE -->

<p><br>[Function]<br><a class=none name='draw-vline'><b>draw-vline</b> <i>x y0 y1 <tt>&amp;key</tt> surface color clipping template</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a vertical line of <a href="#color">COLOR</a> from <code>Y0</code> to <code>Y1</code> through <code>X</code> onto <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X</code> is the horizontal <code>INTEGER</code> coordinate that the vertical line must intersect.</li><li><code>Y0</code> and <code>Y1</code> are the vertical start and end points of the line, of <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the line color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> is <code>NIL</code> The default is <code>NIL</code> as the SDL library will perform the necessary clipping automatically.</li><li><code>:TEMPLATE</code> specifies an optional <a href="#rectangle">RECTANGLE</a> to fill the surface. Will not free <code>TEMPLATE</code>.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for DRAW-VLINE -->


<!-- Entry for ENABLE-ALPHA -->

<p><br>[Function]<br><a class=none name='enable-alpha'><b>enable-alpha</b> <i>value <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Enable surface alpha blending for when <code>T</code>. Disable surface alpha blending when <code>NIL</code>. A <code>SURFACE</code> need not have a pixel alpha component (RGBA) to use surface alpha blending. </p>

</blockquote>

<!-- End of entry for ENABLE-ALPHA -->


<!-- Entry for ENABLE-COLOR-KEY -->

<p><br>[Function]<br><a class=none name='enable-color-key'><b>enable-color-key</b> <i>value <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Enables color keying when <code>T</code>. Disable color keying when <code>NIL</code> </p>

</blockquote>

<!-- End of entry for ENABLE-COLOR-KEY -->


<!-- Entry for ENABLE-KEY-REPEAT -->

<p><br>[Function]<br><a class=none name='enable-key-repeat'><b>enable-key-repeat</b> <i>delay interval</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Enables the keyboard repeat rate. DELAY specifies how long the key must be pressed before it begins repeating, it then repeats at the speed specified by INTERVAL. Both DELAY and INTERVAL are expressed in milliseconds. Setting DELAY or INTERVAL to NIL will set the default values of SDL-DEFAULT-REPEAT-DELAY and SDL-DEFAULT-REPEAT-INTERVAL respectively. </p>

</blockquote>

<!-- End of entry for ENABLE-KEY-REPEAT -->


<!-- Entry for ENABLE-KEY-REPEAT-P -->

<p><br>[Function]<br><a class=none name='enable-key-repeat-p'><b>enable-key-repeat-p</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current keyboard DELAY and INTERVAL repeat rate in milliseconds as (VALUES DELAY INTERVAL). </p>

</blockquote>

<!-- End of entry for ENABLE-KEY-REPEAT-P -->


<!-- Entry for ENABLE-RLE-ACCEL -->

<p><br>[Function]<br><a class=none name='enable-rle-accel'><b>enable-rle-accel</b> <i>value <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Enables RLE blit acceleration when <code>T</code>, disables RLE acceleration when <code>NIL</code>. RLE acceleration can substantially speed up blitting of images with large horizontal runs of transparent pixels (i.e., pixels that match the key color). </p>

</blockquote>

<!-- End of entry for ENABLE-RLE-ACCEL -->


<!-- Entry for ENABLE-UNICODE -->

<p><br>[Function]<br><a class=none name='enable-unicode'><b>enable-unicode</b> <i>state</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Unicode translation is enabled with STATE is T, and disabled when STATE is NIL. To obtain the character codes corresponding to received keyboard events, Unicode translation must first be turned on using this function. The translation incurs a slight overhead for each keyboard event and is therefore disabled by default. For each subsequently received key down event, the unicode member of the SDL_keysym structure will then contain the corresponding character code, or zero for keysyms that do not correspond to any character code. Note that only key press events will be translated, not release events. Returns the previous unicode translation state. </p>

</blockquote>

<!-- End of entry for ENABLE-UNICODE -->


<!-- Entry for ENABLE-UNICODE-P -->

<p><br>[Function]<br><a class=none name='enable-unicode-p'><b>enable-unicode-p</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Queries the current state of Unicode keyboard translation. Returns T if enabled, NIL if disabled. </p>

</blockquote>

<!-- End of entry for ENABLE-UNICODE-P -->


<!-- Entry for FILL-SURFACE -->

<p><br>[Function]<br><a class=none name='fill-surface'><b>fill-surface</b> <i>color <tt>&amp;key</tt> template surface update clipping</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Fills surface with the specified <code>COLOR</code>.    <code>:TEMPLATE</code> accepts  a <code>RECTANGLE</code> defining the fill bounds.    <code>The surface is updated when </code>:UPDATE` </p>

</blockquote>

<!-- End of entry for FILL-SURFACE -->


<!-- Entry for FILL-SURFACE-* -->

<p><br>[Function]<br><a class=none name='fill-surface-*'><b>fill-surface-*</b> <i>r g b <tt>&amp;key</tt> a template surface update clipping</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Fill the surface with the specified color <code>R</code> <code>G</code> <code>B</code> <code>:A</code> <code>A</code>.  See <a href="#fill-surface">FILL-SURFACE</a>. </p>

</blockquote>

<!-- End of entry for FILL-SURFACE-* -->


<!-- Entry for FLOOD-FILL -->

<p><br>[Function]<br><a class=none name='flood-fill'><b>flood-fill</b> <i>point <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#flood-fill-*">FLOOD-FILL-*</a>. </p><h5>Parameters</h5><ul><li>POINT is the position to state the fill, of type <code>POINT</code>.</li></ul>

</blockquote>

<!-- End of entry for FLOOD-FILL -->


<!-- Entry for FLOOD-FILL-* -->

<p><br>[Function]<br><a class=none name='flood-fill-*'><b>flood-fill-*</b> <i>x y <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Performs a flood fill of surface <code>SURFACE</code> with color <code>COLOR</code>. The fill starts at the position specified by the <code>X</code> and <code>Y</code> coordinates. Uses a stack based flood fill that does a lot of consing because it uses PUSH/POP as the stack.  This function is fast. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> are <code>INTEGER</code> coordinates.</li><li><code>SURFACE</code> is the target surface, of type <code>SDL:SDL-SURFACE</code>. Bound to <code>SDL:*DEFAULT-SURFACE*</code> if unspecified.</li><li><code>COLOR</code> is the fill color, of type <code>SDL:COLOR</code> or <code>SDL:COLOR-A</code>. Bound to <code>SDL:*DEFAULT-COLOR*</code> if unspecified.</li></ul>

</blockquote>

<!-- End of entry for FLOOD-FILL-* -->


<!-- Entry for FLOOD-FILL-STACK -->

<p><br>[Function]<br><a class=none name='flood-fill-stack'><b>flood-fill-stack</b> <i>point <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#flood-fill-stack-*">FLOOD-FILL-STACK-*</a>. </p><h5>Parameters</h5><ul><li>POINT is the position to state the fill, of type <code>POINT</code>.</li></ul>

</blockquote>

<!-- End of entry for FLOOD-FILL-STACK -->


<!-- Entry for FLOOD-FILL-STACK-* -->

<p><br>[Function]<br><a class=none name='flood-fill-stack-*'><b>flood-fill-stack-*</b> <i>x y <tt>&amp;key</tt> surface color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#flood-fill-*">FLOOD-FILL-*</a>. </p><p><code>FLOOD-FILL-STACK-*</code> is maintains an internal array-based stack. </p><p><em>Note</em>: More of an experiment to see if an array would be faster than a bunch of consing.  The timing of both functions indicates they run at the same speed. With compiler declarations it may have better results.  Another disadvantage to this is it preallocates the stack, chewing up quite a bit of ram. </p>

</blockquote>

<!-- End of entry for FLOOD-FILL-STACK-* -->


<!-- Entry for FP -->

<p><br>[Generic accessor]<br><a class=none name='fp'><b>fp</b> <i>rectangle-array</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>fp</b> <i>rectangle-array</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the foreign pointer in FOREIGN-OBJECT </p>

</blockquote>

<!-- End of entry for FP -->


<!-- Entry for FP -->

<p><br>[Specialized accessor]<br><a class=none><b>fp</b> <i>(rectangle-array rectangle-array)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>fp</b> <i>(rectangle-array rectangle-array)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FP -->


<!-- Entry for FP -->

<p><br>[Specialized accessor]<br><a class=none><b>fp</b> <i>(rectangle-array color-a)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>fp</b> <i>(rectangle-array color-a)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FP -->


<!-- Entry for FP -->

<p><br>[Specialized accessor]<br><a class=none><b>fp</b> <i>(rectangle-array color)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>fp</b> <i>(rectangle-array color)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FP -->


<!-- Entry for FP -->

<p><br>[Method]<br><a class=none><b>fp</b> <i>(rectangle-array foreign-object)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FP -->


<!-- Entry for FRAME-RATE -->

<p><br>[Accessor]<br><a class=none name='frame-rate'><b>frame-rate</b> <i><tt>&amp;optional</tt> fpsmanager</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>frame-rate</b> <i><tt>&amp;optional</tt> fpsmanager</i><tt>)</tt> <i>rate</i><tt>)</tt></a>
<blockquote><br>

<p>Manage the target frame rate for the game loop. <code>RATE</code> &gt; <code>0</code> will lock the game loop to the specified frame rate, and calculate the average frame rate over a number of frames. <code>RATE</code> = <code>0</code> will unlock the frame rate, and calculate the average frame rate over a number of frames. <code>RATE</code> &lt; <code>0</code> will unlock the frame rate. The average frane rate is not calculated. </p><p>See <a href="#with-events">WITH-EVENTS</a>, and <a href="#average-fps">AVERAGE-FPS</a>. </p>

</blockquote>

<!-- End of entry for FRAME-RATE -->


<!-- Entry for FREE -->

<p><br>[Generic function]<br><a class=none name='free'><b>free</b> <i>foreign-object</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>The general explicit cleanup method for the FOREIGN-OBJECT wrapper class. Objects that subclass FOREIGN-OBJECT should specify an :AFTER method on FREE to clean up any additional fields, if necessary. </p>

</blockquote>

<!-- End of entry for FREE -->


<!-- Entry for FREE -->

<p><br>[Method]<br><a class=none><b>free</b> <i>(foreign-object display-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Freeing the display surface is not a valid operation. </p>

</blockquote>

<!-- End of entry for FREE -->


<!-- Entry for FREE -->

<p><br>[Method]<br><a class=none><b>free</b> <i>(foreign-object color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FREE -->


<!-- Entry for FREE -->

<p><br>[Method]<br><a class=none><b>free</b> <i>(foreign-object foreign-object)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FREE -->


<!-- Entry for FREE-CACHED-SURFACE -->

<p><br>[Generic function]<br><a class=none name='free-cached-surface'><b>free-cached-surface</b> <i>font</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FREE-CACHED-SURFACE -->


<!-- Entry for FREE-CACHED-SURFACE -->

<p><br>[Method]<br><a class=none><b>free-cached-surface</b> <i>(font font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for FREE-CACHED-SURFACE -->


<!-- Entry for G -->

<p><br>[Generic accessor]<br><a class=none name='g'><b>g</b> <i>color</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>g</b> <i>color</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for G -->


<!-- Entry for G -->

<p><br>[Specialized accessor]<br><a class=none><b>g</b> <i>(color color)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>g</b> <i>(color color)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for G -->


<!-- Entry for GET-CLIP-RECT -->

<p><br>[Function]<br><a class=none name='get-clip-rect'><b>get-clip-rect</b> <i><tt>&amp;key</tt> surface rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the clipping <a href="#rectangle">RECTANGLE</a>. </p>

</blockquote>

<!-- End of entry for GET-CLIP-RECT -->


<!-- Entry for GET-FONT-ASCENT -->

<p><br>[Function]<br><a class=none name='get-font-ascent'><b>get-font-ascent</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the maximum pixel ascent of all glyphs of font <code>FONT</code>. This can also be interpreted as the distance from the top of the font to the baseline. It could be used when drawing an individual glyph relative to a top point, by combining it with the glyph&#039;s maxy metric to resolve the top of the rectangle used when blitting the glyph on the screen. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the ascent of the <code>FONT</code> as an <code>INTEGER</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-ASCENT -->


<!-- Entry for GET-FONT-DESCENT -->

<p><br>[Function]<br><a class=none name='get-font-descent'><b>get-font-descent</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the maximum pixel descent of all glyphs of font <code>FONT</code>. This can also be interpreted as the distance from the baseline to the bottom of the font. It could be used when drawing an individual glyph relative to a bottom point, by combining it with the glyphs maxy metric to resolve the top of the rectangle used when blitting the glyph on the screen. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the descent of the <code>FONT</code> as an <code>INTEGER</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-DESCENT -->


<!-- Entry for GET-FONT-FACE-FAMILY-NAME -->

<p><br>[Function]<br><a class=none name='get-font-face-family-name'><b>get-font-face-family-name</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current font face family name of font <code>FONT</code> or <code>NIL</code> if the information is unavailable. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the name of the <code>FONT</code> face family name as a <code>STRING</code>, or <code>NIL</code> if unavailable.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-FACE-FAMILY-NAME -->


<!-- Entry for GET-FONT-FACE-STYLE-NAME -->

<p><br>[Function]<br><a class=none name='get-font-face-style-name'><b>get-font-face-style-name</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current font face style name of font <code>FONT</code>, or <code>NIL</code> if the information is unavailable. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the name of the <code>FONT</code> face style as a <code>STRING</code>, or <code>NIL</code> if unavailable.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-FACE-STYLE-NAME -->


<!-- Entry for GET-FONT-FACES -->

<p><br>[Function]<br><a class=none name='get-font-faces'><b>get-font-faces</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the number of faces &#039;sub-fonts&#039; available in the font <code>FONT</code>. This is a count of the number of specific fonts (based on size and style and other  typographical features perhaps) contained in the font itself. It seems to be a useless  fact to know, since it cant be applied in any other <code>SDL_TTF</code> functions. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the number of faces in the <code>FONT</code> as an <code>INTEGER</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-FACES -->


<!-- Entry for GET-FONT-HEIGHT -->

<p><br>[Function]<br><a class=none name='get-font-height'><b>get-font-height</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the maximum pixel height of all glyphs of font <code>FONT</code>. Use this height for rendering text as close together vertically as possible, though adding at least one pixel height to it will space it so they can&#039;t touch. Remember that <code>SDL_TTF</code> doesn&#039;t handle multiline printing so you are responsible for line spacing, see <a href="#get-font-line-skip">GET-FONT-LINE-SKIP</a> as well. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Retuns the height of the <code>FONT</code> as an <code>INTEGER</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-HEIGHT -->


<!-- Entry for GET-FONT-LINE-SKIP -->

<p><br>[Function]<br><a class=none name='get-font-line-skip'><b>get-font-line-skip</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the recommended pixel height of a rendered line of text of the font <code>FONT</code>. This is usually larger than the <a href="#get-font-height">GET-FONT-HEIGHT</a> of the font. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the pixel height of the <code>FONT</code> as an <code>INTEGER</code>.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-LINE-SKIP -->


<!-- Entry for GET-FONT-SIZE -->

<p><br>[Function]<br><a class=none name='get-font-size'><b>get-font-size</b> <i>text <tt>&amp;key</tt> size font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Calculates and returns the resulting <code>SIZE</code> of the <code>SDL:SURFACE</code> that is required to render the text <code>TEXT</code>, or <code>NIL</code> on error. No actual rendering is performed, however correct kerning is calculated for the actual width. The height returned is the same as returned using <a href="#get-font-height">GET-FONT-HEIGHT</a>. </p><h5>Parameters</h5><ul><li><code>TEXT</code> is the string to size, of type <code>STRING</code>.</li><li><code>SIZE</code> must be one of; <code>:W</code> for the text width or <code>:H</code> for the text height.</li><li><code>FONT</code> is the font used to calculate the size of the <code>TEXT</code>. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Returns the width or height of the specified <code>SDL:SURFACE</code>, or <code>NIL</code> upon error.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-SIZE -->


<!-- Entry for GET-FONT-STYLE -->

<p><br>[Function]<br><a class=none name='get-font-style'><b>get-font-style</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the rendering style of the font <code>FONT</code>. If no style is set then <code>:STYLE-NORMAL</code> is returned, or <code>NIL</code> upon error. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binfs to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Retuns the font style as one or more of: <code>:STYLE-NORMAL</code>, <code>:STYLE-BOLD</code>, <code>:STYLE-ITALIC</code>, <code>:STYLE-UNDERLINE</code></li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-FONT-STYLE -->


<!-- Entry for GET-GLYPH-METRIC -->

<p><br>[Function]<br><a class=none name='get-glyph-metric'><b>get-glyph-metric</b> <i>ch <tt>&amp;key</tt> metric font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the glyph metrics <code>METRIC</code> for the character <code>CH</code>, or <code>NIL</code> upon error. </p><h5>Parameters</h5><ul><li><code>CH</code> is a UNICODE chararacter specified as an <code>INTEGER</code>.</li><li><code>FONT</code> is a <code>FONT</code> object from which to retrieve the glyph metrics of the character <code>CH</code>. Binds to <code>*DEFAULT-FONT*</code> by default. </li><li><code>METRIC</code> is a <code>KEY</code>word argument and may be one of; <code>:MINX</code>, for the minimum <code>X</code> offset.<br />
<code>:MAXX</code>, for the maximum <code>X</code> offset. <code>:MINY</code>, for the minimum <code>Y</code> offset. <code>:MAXY</code>, for the maximum <code>Y</code> offset. <code>:ADVANCE</code>, for the advance offset. </li></ul><h5>Returns</h5><ul><li>Returns the glyph metric as an <code>INTEGER</code>.</li></ul><h5>Example</h5><pre><code>(GET-GLYPH-METRIC UNICODE-CHAR :METRIC :MINX :FONT *DEFAULT-FONT*) </code></pre><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for GET-GLYPH-METRIC -->


<!-- Entry for GET-KEY-STATE -->

<p><br>[Function]<br><a class=none name='get-key-state'><b>get-key-state</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current keypress state of the key KEY. Returns T if the SDL-KEY is pressed, returns NIL if SDL-KEY is not pressed. Note: Use SDL_PumpEvents to update the state array. Note: This function gives you the current state after all events have been processed, so if a key or button has been pressed and released before you process events, then the pressed state will never show up in the getstate calls. Note: This function doesn&#039;t take into account whether shift has been pressed or not. For example: (GET-KEY-STATE :SDL-KEY-F1) </p>

</blockquote>

<!-- End of entry for GET-KEY-STATE -->


<!-- Entry for GET-NATIVE-WINDOW -->

<p><br>[Function]<br><a class=none name='get-native-window'><b>get-native-window</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a foreign pointer to the native SDL display window. </p>

</blockquote>

<!-- End of entry for GET-NATIVE-WINDOW -->


<!-- Entry for GET-POINT -->

<p><br>[Generic function]<br><a class=none name='get-point'><b>get-point</b> <i>object</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> coordinates of object <code>OBJ</code> as a <code>POINT</code>. </p>

</blockquote>

<!-- End of entry for GET-POINT -->


<!-- Entry for GET-POINT -->

<p><br>[Method]<br><a class=none><b>get-point</b> <i>(object sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>POINT</code> position coordinates of <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for GET-POINT -->


<!-- Entry for GET-POINT -->

<p><br>[Method]<br><a class=none><b>get-point</b> <i>(object rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> coordinates of rectangle <code>RECTANGLE</code> as a <code>POINT</code>. </p>

</blockquote>

<!-- End of entry for GET-POINT -->


<!-- Entry for GET-POINT -->

<p><br>[Method]<br><a class=none><b>get-point</b> <i>(object vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the point <code>POINT</code>. </p>

</blockquote>

<!-- End of entry for GET-POINT -->


<!-- Entry for GET-POSITION -->

<p><br>[Generic function]<br><a class=none name='get-position'><b>get-position</b> <i>object</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#get-POINT">GET-POINT</a> </p>

</blockquote>

<!-- End of entry for GET-POSITION -->


<!-- Entry for GET-POSITION -->

<p><br>[Method]<br><a class=none><b>get-position</b> <i>(object sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#get-point">GET-POINT</a>. </p>

</blockquote>

<!-- End of entry for GET-POSITION -->


<!-- Entry for GET-POSITION -->

<p><br>[Method]<br><a class=none><b>get-position</b> <i>(object rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#get-POINT">GET-POINT</a> </p>

</blockquote>

<!-- End of entry for GET-POSITION -->


<!-- Entry for GET-RECTANGLE -->

<p><br>[Generic function]<br><a class=none name='get-rectangle'><b>get-rectangle</b> <i>obj</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the rectangle <code>RECTANGLE</code>. </p>

</blockquote>

<!-- End of entry for GET-RECTANGLE -->


<!-- Entry for GET-RECTANGLE -->

<p><br>[Method]<br><a class=none><b>get-rectangle</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the rectangle <code>RECTANGLE</code>. </p>

</blockquote>

<!-- End of entry for GET-RECTANGLE -->


<!-- Entry for GET-SURFACE-RECT -->

<p><br>[Function]<br><a class=none name='get-surface-rect'><b>get-surface-rect</b> <i><tt>&amp;key</tt> surface rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for GET-SURFACE-RECT -->


<!-- Entry for HANDLE-KEY-DOWN -->

<p><br>[Function]<br><a class=none name='handle-key-down'><b>handle-key-down</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for HANDLE-KEY-DOWN -->


<!-- Entry for HANDLE-KEY-UP -->

<p><br>[Function]<br><a class=none name='handle-key-up'><b>handle-key-up</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for HANDLE-KEY-UP -->


<!-- Entry for HEIGHT -->

<p><br>[Generic accessor]<br><a class=none name='height'><b>height</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>height</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for HEIGHT -->


<!-- Entry for HEIGHT -->

<p><br>[Method]<br><a class=none><b>height</b> <i>(obj font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for HEIGHT -->


<!-- Entry for HEIGHT -->

<p><br>[Method]<br><a class=none><b>height</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the height of <code>SURFACE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for HEIGHT -->


<!-- Entry for HEIGHT -->

<p><br>[Specialized accessor]<br><a class=none><b>height</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>height</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>INTEGER</code> height of the rectangle <code>RECTANGLE</code>. </p>

</blockquote>

<!-- End of entry for HEIGHT -->


<!-- Entry for IMAGE-P -->

<p><br>[Generic function]<br><a class=none name='image-p'><b>image-p</b> <i>source image-type</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> when the image type in <code>SOURCE</code> is of <code>IMAGE-TYPE</code>. Returns <code>NIL</code> otherwise. Attempts to detect the image type using the <em>magic number</em> contained in the image if one is available.  <code>NIL</code> is always returned for images of type <code>TGA</code> as a <code>TGA</code> image does not contain a <em>magic number</em>.  <code>IMAGE-TYPE</code> must be one of <code>:BMP</code>, <code>:GIF</code>, <code>:JPG</code>, <code>:LBM</code>, <code>:PCX</code>, <code>:PNG</code>, <code>:PNM</code>, <code>:TIF</code>, <code>:XCF</code>, <code>:XPM</code> or <code>:XV</code>. </p><h5>Example</h5><pre><code>(RWOPS-P SOURCE :IMAGE-TYPE :BMP)  
(IMAGE-P &quot;image.bmp&quot; :IMAGE-TYPE :BMP) </code></pre><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-IMAGE</em></li></ul>

</blockquote>

<!-- End of entry for IMAGE-P -->


<!-- Entry for IMAGE-TYPE-OF -->

<p><br>[Generic function]<br><a class=none name='image-type-of'><b>image-type-of</b> <i>source</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the type of image in source <code>SOURCE</code>. Attempts to detect the image type using the <em>magic number</em> contained in the image if one is available.  Returns one of <code>:BMP</code>, <code>:GIF</code>, <code>:JPG</code>, <code>:LBM</code>, <code>:PCX</code>, <code>:PNG</code>, <code>:PNM</code>, <code>:TIF</code>, <code>:XCF</code>, <code>:XPM</code> or <code>:XV</code>, if the image type can be determined. Returns <code>NIL</code> if the image cannot be determined (The <em>magic number</em> is not supported or the <em>magic number</em> is not found).  <code>NIL</code> is always returned for images of type <code>TGA</code> as a <code>TGA</code> image does not contain a <em>magic number</em>. </p><h5>Example</h5><pre><code>(IMAGE-TYPE-OF SOURCE)  
(IMAGE-TYPE-OF &quot;image.bmp&quot;) </code></pre><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-IMAGE</em></li></ul>

</blockquote>

<!-- End of entry for IMAGE-TYPE-OF -->


<!-- Entry for INIT-SDL -->

<p><br>[Function]<br><a class=none name='init-sdl'><b>init-sdl</b> <i><tt>&amp;optional</tt> init</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Initalizes the SDL library when the <code>OPTIONAL</code> parameter <code>INIT</code> is <code>T</code>, or the value returned by <a href="#sdl-init-on-startup">SDL-INIT-ON-STARTUP</a> is <code>T</code>. </p>

</blockquote>

<!-- End of entry for INIT-SDL -->


<!-- Entry for INIT-SUB-SYSTEMS -->

<p><br>[Function]<br><a class=none name='init-sub-systems'><b>init-sub-systems</b> <i><tt>&amp;optional</tt> flags</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Initializes the SDL subsystems specified in <code>FLAGS</code>. <code>FLAGS</code> is an <code>INTEGER</code> bitmask containing the logior of zero or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code> and <code>SDL-INIT-NOPARACHUTE</code>. </p><p><code>INIT-SUB-SYSTEMS</code> can be called only after SDL is succesfully initialized by <a href="#init-sdl">INIT-SDL</a>. </p>

</blockquote>

<!-- End of entry for INIT-SUB-SYSTEMS -->


<!-- Entry for INITIALISE-DEFAULT-FONT -->

<p><br>[Function]<br><a class=none name='initialise-default-font'><b>initialise-default-font</b> <i><tt>&amp;optional</tt> font-definition</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <a href="#sdl-bitmap-font">SDL-BITMAP-FONT</a> initialized from <code>FONT-DEFINITION</code> data, or <code>NIL</code> if the font cannot be created. <code>FONT-DEFINITION</code> is set to <code>*font-8x8*</code> if unspecified. Binds the symbol <code>*DEFAULT-FONT*</code> to the new font to be used as the default for subsequent font rendering or drawing operations. </p><h5>Packages</h5><ul><li>Aslo supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for INITIALISE-DEFAULT-FONT -->


<!-- Entry for INITIALISE-FONT -->

<p><br>[Generic function]<br><a class=none name='initialise-font'><b>initialise-font</b> <i>font-definition</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <a href="#sdl-bitmap-font">SDL-BITMAP-FONT</a> initialized from <code>FONT-DEFINITION</code> data, or <code>NIL</code> if the font cannot be created. <code>FONT-DEFINITION</code> must be one of the following built-in fonts: <code>*FONT-10X20*</code>, <code>*FONT-5X7*</code>, <code>*FONT-5X8*</code>, <code>*FONT-6X10*</code>, <code>*FONT-6X12*</code>, <code>*FONT-6X13*</code>, <code>*FONT-6X13B*</code>, <code>*FONT-6X13O*</code>, <code>*FONT-6X9*</code>, <code>*FONT-7X13*</code>, <code>*FONT-7X13B*</code>, <code>*FONT-7X13O*</code>, <code>*FONT-7X14*</code>, <code>*FONT-7X14B*</code>, <code>*FONT-8X13*</code>, <code>*FONT-8X13B*</code>, <code>*FONT-8X13O*</code>, <code>*FONT-8X8*</code>, <code>*FONT-9X15*</code>, <code>*FONT-9X15B*</code>, <code>*FONT-9X18*</code> OR <code>*FONT-9X18B*</code>. </p><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for INITIALISE-FONT -->


<!-- Entry for INITIALISE-FONT -->

<p><br>[Method]<br><a class=none><b>initialise-font</b> <i>(font-definition simple-font-definition)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for INITIALISE-FONT -->


<!-- Entry for INITIALISE-FONT -->

<p><br>[Method]<br><a class=none><b>initialise-font</b> <i>(font-definition bitmap-font-definition)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for INITIALISE-FONT -->


<!-- Entry for INITIALISE-INPUT-UTIL -->

<p><br>[Function]<br><a class=none name='initialise-input-util'><b>initialise-input-util</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Initialises the input util system. This just creates the data structure that key press information is stored in, and maintains a global variable to track initialisation status. </p><h5>Parameters</h5><h5>Returns</h5>

</blockquote>

<!-- End of entry for INITIALISE-INPUT-UTIL -->


<!-- Entry for INITIALIZE-ON-STARTUP -->

<p><br>[Function]<br><a class=none name='initialize-on-startup'><b>initialize-on-startup</b> <i><tt>&amp;rest</tt> flags</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the SDL subsystems that must be initialized in subsequent calls to <a href="#init-sub-systems">INIT-SUB-SYSTEMS</a>. </p><h5>Parameters</h5><ul><li><code>FLAGS</code> may be one or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code> and <code>SDL-INIT-NOPARACHUTE</code>. </li></ul><h5>Returns</h5><ul><li>Returns an INTEGER bitmask of the SDL subsystems in <code>FLAGS</code>.</li></ul><h5>Example</h5><pre><code>(INITIALIZE-ON-STARTUP SDL:SDL-INIT-VIDEO SDL:SDL-INIT-CDROM) </code></pre>

</blockquote>

<!-- End of entry for INITIALIZE-ON-STARTUP -->


<!-- Entry for INITIALIZED-SUB-SYSTEMS-P -->

<p><br>[Function]<br><a class=none name='initialized-sub-systems-p'><b>initialized-sub-systems-p</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a list of the initialized SDL subsystems. </p>

</blockquote>

<!-- End of entry for INITIALIZED-SUB-SYSTEMS-P -->


<!-- Entry for IS-FONT-FACE-FIXED-WIDTH -->

<p><br>[Function]<br><a class=none name='is-font-face-fixed-width'><b>is-font-face-fixed-width</b> <i><tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if the font face is of a fixed width, or <code>NIL</code> otherwise. Fixed width fonts are monospace, meaning every character that exists in the font is the same width. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object. Binds to <code>*DEFAULT-FONT*</code> by default.</li></ul><h5>Returns</h5><ul><li>Retuns <code>T</code> if <code>FONT</code> is of fixed width, and <code>NIL</code> otherwise.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for IS-FONT-FACE-FIXED-WIDTH -->


<!-- Entry for IS-VALID-PTR -->

<p><br>[Function]<br><a class=none name='is-valid-ptr'><b>is-valid-ptr</b> <i>pointer</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns T if pointer is not NULL and is a valid CFFI pointer to a foreign object. </p>

</blockquote>

<!-- End of entry for IS-VALID-PTR -->


<!-- Entry for KEY-HELD-P -->

<p><br>[Function]<br><a class=none name='key-held-p'><b>key-held-p</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for KEY-HELD-P -->


<!-- Entry for KEY-HELD-TIME -->

<p><br>[Function]<br><a class=none name='key-held-time'><b>key-held-time</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for KEY-HELD-TIME -->


<!-- Entry for KEY-PRESSED-P -->

<p><br>[Function]<br><a class=none name='key-pressed-p'><b>key-pressed-p</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for KEY-PRESSED-P -->


<!-- Entry for KEY-REPEAT-DELAY -->

<p><br>[Function]<br><a class=none name='key-repeat-delay'><b>key-repeat-delay</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current key repeat delay, in milliseconds. </p>

</blockquote>

<!-- End of entry for KEY-REPEAT-DELAY -->


<!-- Entry for KEY-REPEAT-INTERVAL -->

<p><br>[Function]<br><a class=none name='key-repeat-interval'><b>key-repeat-interval</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the current key repeat interval, in milliseconds. </p>

</blockquote>

<!-- End of entry for KEY-REPEAT-INTERVAL -->


<!-- Entry for KEY= -->

<p><br>[Function]<br><a class=none name='key='><b>key=</b> <i>key1 key2</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for KEY= -->


<!-- Entry for LIST-MODES -->

<p><br>[Function]<br><a class=none name='list-modes'><b>list-modes</b> <i>flags <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a LIST of vectors sorted largest to smallest that contains the width and height dimensions of the screen that will support the pixel format of the specified surface <code>SURFACE</code> and video flags <code>FLAGS</code>. <code>LIST-MODES</code> must be called after SDL is initialised using <a href="#init-sdl">INIT-SDL</a> or <a href="#with-init">WITH-INIT</a>. </p><h5>Parameters</h5><ul><li><code>FLAGS</code> is a bitmasked logior of one or more of the following; <a href="#sdl-sw-surface">SDL-SW-SURFACE</a>, <a href="#sdl-hw-surface">SDL-HW-SURFACE</a>, <a href="#sdl-async-blit">SDL-ASYNC-BLIT</a>, <a href="#sdl-any-format">SDL-ANY-FORMAT</a>, <a href="#sdl-hw-palette">SDL-HW-PALETTE</a>, <a href="#sdl-doublebuf">SDL-DOUBLEBUF</a>, <a href="#sdl-fullscreen">SDL-FULLSCREEN</a>, <a href="#sdl-opengl">SDL-OPENGL</a>, <a href="#sdl-resizable">SDL-RESIZABLE</a> and <a href="#sdl-no-frame">SDL-NO-FRAME</a>. </li><li><code>SURFACE</code> A surface of type <a href="#sdl-surface]">SDL-SURFACE</a>, or <code>NIL</code>. WHEN <code>NIL</code>, the pixel format will be that returned by <a href="#sdl-get-video-info]">SDL-GET-VIDEO-INFO</a>. </li></ul><h5>Returns</h5><ul><li>Returns a list of <code>VECTOR</code>s of display dimensions, sorted largest to smallest, that will support the pixel format of surface <code>SURFACE</code>; for example <code>(#(1024 768) #(640 480) #(512 384) #(320 240))</code>. Returns <code>NIL</code> if there are no dimensions available for a particular pixel format. Returns <code>T</code> if any dimension will support the pixel format and video flags. </li></ul><h5>Example</h5><pre><code>(LIST-MODES &#039;(SDL-HW-SURFACE SDL-FULLSCREEN)) </code></pre>

</blockquote>

<!-- End of entry for LIST-MODES -->


<!-- Entry for LIST-SUB-SYSTEMS -->

<p><br>[Function]<br><a class=none name='list-sub-systems'><b>list-sub-systems</b> <i>flag</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a list of SDL subsystems that are specified in <code>FLAGS</code>. </p><p><code>FLAGS</code> is an <code>INTEGER</code> bitmask containing the logior of zero or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code> and <code>SDL-INIT-NOPARACHUTE</code>. </p>

</blockquote>

<!-- End of entry for LIST-SUB-SYSTEMS -->


<!-- Entry for LOAD-IMAGE -->

<p><br>[Generic function]<br><a class=none name='load-image'><b>load-image</b> <i>source <tt>&amp;key</tt> color-key alpha image-type force free-rwops color-key-at</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates and returns a new <code>SURFACE</code> from the image in <code>SOURCE</code>, or returns <code>NIL</code> if <code>SOURCE</code> does not contain a valid image or the image type cannot be determined. </p><p>The <em>magic number</em> if present is be used to determine the image type. To load an image when the <em>magic number</em> is unavailable (image formats such as <code>TGA</code> do not contain a <em>magic number</em>), specify the image type using <code>:IMAGE-TYPE</code>.  All non-magicable image formats, such as <code>TGA</code>, must be specified using <code>IMAGE-TYPE</code>. To load a TGA image use <code>:IMAGE-TYPE :TGA</code> </p><h5>Parameters</h5><ul><li><code>SOURCE</code> is an image.</li><li><code>COLOR-KEY</code> sets the color key, and turns on color keying.</li><li>&#039;COLOR-KEY-AT&#039; uses the pixel color at <code>POINT</code> x/y as the color key, and turns on color keying.</li><li><code>ALPHA</code> sets the transparency level for the surface, and turns on alpha blending. Must be in the range 0-255, where 255 is opaque and 0 is transparent.</li><li><code>IMAGE-TYPE</code> specifies the image type. May be <code>:BMP</code>, <code>:GIF</code>, <code>:JPG</code>, <code>:LBM</code>, <code>:PCX</code>, <code>:PNG</code>, <code>:PNM</code>, <code>:TGA</code>, <code>:TIF</code>, <code>:XCF</code>, <code>:XPM</code> or <code>:XV</code>.  The image type is determined using the <em>magic number</em> when present in the image if <code>NIL</code>.  If the <em>magic number</em> is available and does not match <code>IMAGE-TYPE</code>, then <code>IMAGE-TYPE</code> is ignored. </li><li><code>FORCE</code> when <code>T</code> will ignore any <em>magic number</em> present in the image and load an image as <code>:IMAGE-TYPE</code>.  Images of type <code>TGA</code> must be loaded using <code>:FORCE T</code>. </li><li><code>FREE-RWOPS</code> will free a RWOPS passed as a parameter in <code>SOURCE</code>. Default is <code>T</code></li></ul><h5>Example</h5><ul><li>To load a <code>BMP</code> image using the <em>magic number</em><p>(LOAD-IMAGE &quot;image.bmp&quot;) </p></li><li>To load a <code>TGA</code> image<p>(LOAD-IMAGE &quot;image.tga&quot; :IMAGE-TYPE :TGA) </p></li><li>Try to load a <code>BMP</code> image as <code>TGA</code><p>(LOAD-IMAGE &quot;image.bmp&quot; :IMAGE-TYPE :BMP :FORCE T) </p></li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-IMAGE</em></li><li><em>LISPBUILDER-SDL</em> only supports <code>BMP</code> images. Any alpha channel present in the source image is ignored. The new <code>SURFACE</code> is created as an <code>RGB</code> surface, not <code>RGBA</code>. </li><li><em>LISPBUILDER-SDL-IMAGE</em> supports the following image formats, <code>BMP</code>, <code>GIF</code>, <code>JPG</code>, <code>LBM</code>, <code>PCX</code>, <code>PNG</code>, <code>PNM</code>, <code>TIF</code>, <code>XCF</code>, <code>XPM</code>, <code>XV</code>. <code>BMP</code> and <code>TGA</code>. Alpha channels are supported. The new <code>SURFACE</code> is created as <code>RGB</code> or <code>RGBA</code> as appropriate. </li><li><code>:IMAGE-TYPE</code> and <code>:FORCE</code> are ignored for <em>LISPBUILDER-SDL</em>.</li></ul>

</blockquote>

<!-- End of entry for LOAD-IMAGE -->


<!-- Entry for LOAD-IMAGE -->

<p><br>[Method]<br><a class=none><b>load-image</b> <i>(source string) <tt>&amp;key</tt> color-key alpha image-type force free-rwops color-key-at</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <code>SURFACE</code> from the file at location <code>FILENAME</code>. </p>

</blockquote>

<!-- End of entry for LOAD-IMAGE -->


<!-- Entry for LOAD-IMAGE -->

<p><br>[Method]<br><a class=none><b>load-image</b> <i>(source vector) <tt>&amp;key</tt> color-key alpha image-type force free-rwops color-key-at</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <code>SURFACE</code> from the byte array in <code>SOURCE</code>. </p>

</blockquote>

<!-- End of entry for LOAD-IMAGE -->


<!-- Entry for LOAD-IMAGE -->

<p><br>[Method]<br><a class=none><b>load-image</b> <i>(source rwops) <tt>&amp;key</tt> color-key alpha image-type force free-rwops color-key-at</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <code>SURFACE</code> from the <code>RWOPS</code> in <code>SOURCE</code>. </p>

</blockquote>

<!-- End of entry for LOAD-IMAGE -->


<!-- Entry for MAP-COLOR -->

<p><br>[Generic function]<br><a class=none name='map-color'><b>map-color</b> <i>color <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Maps <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a> to the pixel format of <a href="#surface">SURFACE</a> and returns the pixel value that best approximates the color value of the surface. If the surface has a palette (8-bit) the index of the closest matching color in the palette will be returned. If the surface has an alpha component it will be returned as all <code>1</code> bits (fully opaque). If the surface color depth is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp format). </p>

</blockquote>

<!-- End of entry for MAP-COLOR -->


<!-- Entry for MAP-COLOR -->

<p><br>[Method]<br><a class=none><b>map-color</b> <i>(color color-a) <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for MAP-COLOR -->


<!-- Entry for MAP-COLOR -->

<p><br>[Method]<br><a class=none><b>map-color</b> <i>(color color) <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for MAP-COLOR -->


<!-- Entry for MAP-COLOR-* -->

<p><br>[Generic function]<br><a class=none name='map-color-*'><b>map-color-*</b> <i>r g b a <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Maps the color specified by the <code>R</code>, <code>G</code>, <code>B</code>, and <code>A</code> color components to the pixel format of <a href="#surface">SURFACE</a> and returns the pixel value that best approximates the color value of the surface. If <code>A</code> is not <code>NIL</code> then the color is assumed to contain an alpha component. See <a href="#map-color">MAP-COLOR</a> for more details. </p>

</blockquote>

<!-- End of entry for MAP-COLOR-* -->


<!-- Entry for MAP-COLOR-* -->

<p><br>[Method]<br><a class=none><b>map-color-*</b> <i>(r integer) (g integer) (b integer) a <tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for MAP-COLOR-* -->


<!-- Entry for NUM-JOYSTICKS -->

<p><br>[Function]<br><a class=none name='num-joysticks'><b>num-joysticks</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for NUM-JOYSTICKS -->


<!-- Entry for PACK-COLOR -->

<p><br>[Generic function]<br><a class=none name='pack-color'><b>pack-color</b> <i>color</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Packs <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a> into a four byte <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for PACK-COLOR -->


<!-- Entry for PACK-COLOR -->

<p><br>[Method]<br><a class=none><b>pack-color</b> <i>(color color-a)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for PACK-COLOR -->


<!-- Entry for PACK-COLOR -->

<p><br>[Method]<br><a class=none><b>pack-color</b> <i>(color color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for PACK-COLOR -->


<!-- Entry for PIXEL-ALPHA-ENABLED-P -->

<p><br>[Generic function]<br><a class=none name='pixel-alpha-enabled-p'><b>pixel-alpha-enabled-p</b> <i>surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if a pixel alpha component (RGBA) is available, or <code>NIL</code> if unavailable (RGB). <em>Note</em>: The pixel alpha component differs from the surface alpha component which is retrieved using <a href="#alpha-enabled-p">ALPHA-ENABLED-P</a>. </p>

</blockquote>

<!-- End of entry for PIXEL-ALPHA-ENABLED-P -->


<!-- Entry for PIXEL-ALPHA-ENABLED-P -->

<p><br>[Method]<br><a class=none><b>pixel-alpha-enabled-p</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for PIXEL-ALPHA-ENABLED-P -->


<!-- Entry for POINT -->

<p><br>[Function]<br><a class=none name='point'><b>point</b> <i><tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates a new <code>POINT</code> set to the specified horizontal <code>X</code> and vertical <code>Y</code> coordinate. </p>

</blockquote>

<!-- End of entry for POINT -->


<!-- Entry for POINT-* -->

<p><br>[Generic function]<br><a class=none name='point-*'><b>point-*</b> <i>point</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> coordinates of the object as a spread. The <code>RESULT</code> is <code>(VALUES X Y)</code> </p>

</blockquote>

<!-- End of entry for POINT-* -->


<!-- Entry for POINT-* -->

<p><br>[Method]<br><a class=none><b>point-*</b> <i>(point sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> position coordinates of <code>SURFACE</code> as a spread. </p>

</blockquote>

<!-- End of entry for POINT-* -->


<!-- Entry for POINT-* -->

<p><br>[Method]<br><a class=none><b>point-*</b> <i>(point rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> coordinates of the rectangle <code>RECTANGLE</code> as a spread.   The <code>RESULT</code> is <code>(VALUES X Y)</code> </p>

</blockquote>

<!-- End of entry for POINT-* -->


<!-- Entry for POINT-* -->

<p><br>[Method]<br><a class=none><b>point-*</b> <i>(point vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code> and <code>Y</code> coordinates of the point <code>POINT</code> as a spread. </p>

</blockquote>

<!-- End of entry for POINT-* -->


<!-- Entry for POSITION-* -->

<p><br>[Generic function]<br><a class=none name='position-*'><b>position-*</b> <i>obj</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#point-*">POINT-*</a> </p>

</blockquote>

<!-- End of entry for POSITION-* -->


<!-- Entry for POSITION-* -->

<p><br>[Method]<br><a class=none><b>position-*</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#position">POSITION</a>. </p>

</blockquote>

<!-- End of entry for POSITION-* -->


<!-- Entry for POSITION-* -->

<p><br>[Method]<br><a class=none><b>position-*</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#point-*">POINT-*</a> </p>

</blockquote>

<!-- End of entry for POSITION-* -->


<!-- Entry for POSITION-* -->

<p><br>[Method]<br><a class=none><b>position-*</b> <i>(obj vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#point-*">POINT-*</a>. </p>

</blockquote>

<!-- End of entry for POSITION-* -->


<!-- Entry for PUSH-QUIT-EVENT -->

<p><br>[Function]<br><a class=none name='push-quit-event'><b>push-quit-event</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Pushes a new <code>SDL_Event</code> of type <code>:SDL-QUIT-EVENT</code> onto the event queue. </p>

</blockquote>

<!-- End of entry for PUSH-QUIT-EVENT -->


<!-- Entry for PUSH-USER-EVENT -->

<p><br>[Function]<br><a class=none name='push-user-event'><b>push-user-event</b> <i><tt>&amp;key</tt> code data1 data2</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Pushes a new <code>SDL_Event</code> of type <code>:SDL-USER-EVENT</code> onto the event queue. </p>

</blockquote>

<!-- End of entry for PUSH-USER-EVENT -->


<!-- Entry for QUERY-CURSOR -->

<p><br>[Function]<br><a class=none name='query-cursor'><b>query-cursor</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Queries the current state of the cursor. Returns <code>T</code> if the cursor is enabled and shown on the display. Returns <code>NIL</code> if the cursor is disabled and hidden. </p>

</blockquote>

<!-- End of entry for QUERY-CURSOR -->


<!-- Entry for QUIT-INPUT-UTIL -->

<p><br>[Function]<br><a class=none name='quit-input-util'><b>quit-input-util</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>This is called when you quit your app to free up the key information data </p><h5>Parameters</h5><h5>Returns</h5>

</blockquote>

<!-- End of entry for QUIT-INPUT-UTIL -->


<!-- Entry for QUIT-ON-EXIT -->

<p><br>[Function]<br><a class=none name='quit-on-exit'><b>quit-on-exit</b> <i><tt>&amp;rest</tt> flags</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets one or more SDL subsystems that must be uninitialized in subsequent calls to <a href="#quit-sub-systems">QUIT-SUB-SYSTEMS</a>. </p><h5>Parameters</h5><ul><li><code>FLAGS</code> may be one or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code>, <code>SDL-INIT-NOPARACHUTE</code>. </li></ul><h5>Returns</h5><ul><li>Returns an INTEGER bitmask of the SDL subsystems in <code>FLAGS</code>.</li></ul><h5>Example</h5><pre><code>(QUIT-ON-EXIT SDL:SDL-INIT-VIDEO SDL:SDL-INIT-CDROM) </code></pre>

</blockquote>

<!-- End of entry for QUIT-ON-EXIT -->


<!-- Entry for QUIT-SDL -->

<p><br>[Function]<br><a class=none name='quit-sdl'><b>quit-sdl</b> <i><tt>&amp;optional</tt> quit</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Uninitalizes the SDL library when the <code>OPTIONAL</code> parameter <code>QUIT</code> is <code>T</code>, or the value returned by <a href="#sdl-quit-on-exit">SDL-QUIT-ON-EXIT</a> is <code>T</code>. </p>

</blockquote>

<!-- End of entry for QUIT-SDL -->


<!-- Entry for QUIT-SUB-SYSTEMS -->

<p><br>[Function]<br><a class=none name='quit-sub-systems'><b>quit-sub-systems</b> <i><tt>&amp;optional</tt> flags</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Uninitializes the SDL subsystems specified in the <code>INTEGER</code> bitmask <code>FLAGS</code>. <code>FLAGS</code> contains the logior of zero or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code>, <code>SDL-INIT-NOPARACHUTE</code>. </p><p><code>QUIT-SUB-SYSTEMS</code> can be called only after SDL is successfully intialized using <a href="#init-sdl">INIT-SDL</a>. </p>

</blockquote>

<!-- End of entry for QUIT-SUB-SYSTEMS -->


<!-- Entry for R -->

<p><br>[Generic accessor]<br><a class=none name='r'><b>r</b> <i>color</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>r</b> <i>color</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for R -->


<!-- Entry for R -->

<p><br>[Specialized accessor]<br><a class=none><b>r</b> <i>(color color)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>r</b> <i>(color color)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for R -->


<!-- Entry for RANDOM+1 -->

<p><br>[Function]<br><a class=none name='random+1'><b>random+1</b> <i>rnd</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a random number in the range 0 &gt; num &lt;= rnd. </p>

</blockquote>

<!-- End of entry for RANDOM+1 -->


<!-- Entry for RANDOM-RECTANGLE -->

<p><br>[Function]<br><a class=none name='random-rectangle'><b>random-rectangle</b> <i>bound-w bound-h <tt>&amp;optional</tt> rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates and return s a new <code>RECTANGLE</code> of random x, y width and height within the specified bounds of width <code>BOUND-W</code> and height <code>BOUND-H</code>. <code>RECTANGLE</code> if unset will force the creation of a new <code>RECTANGLE</code> object. <code>RECTANGLE</code> if set will be modified with the coordinates. </p>

</blockquote>

<!-- End of entry for RANDOM-RECTANGLE -->


<!-- Entry for READ-PIXEL -->

<p><br>[Function]<br><a class=none name='read-pixel'><b>read-pixel</b> <i>point <tt>&amp;key</tt> clipping surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#read-pixel-*">READ-PIXEL-*</a>. </p><h5>Parameters</h5><ul><li><code>POINT</code> is the <a href="#point">POINT</a> coordinates of the pixel.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for READ-PIXEL -->


<!-- Entry for READ-PIXEL-* -->

<p><br>[Function]<br><a class=none name='read-pixel-*'><b>read-pixel-*</b> <i>x y <tt>&amp;key</tt> clipping surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Read the <a href="#color">COLOR</a> of the pixel at <code>X</code> and <code>Y</code> coordiates from <a href="#surface">SURFACE</a>. </p><h5>Parameters</h5><ul><li><code>X</code> and <code>Y</code> specify the coordinates of the pixel, and are of type <code>INTEGER</code>.</li><li><code>:SURFACE</code> is the target <a href="#surface">SURFACE</a>.</li><li><code>:COLOR</code> is the pixel color, of <a href="#color">COLOR</a> or <a href="#color-a">COLOR-A</a>.</li><li><code>:CLIPPING</code> when left as the default value <code>T</code> will ensure that the pixel is clipped to the dimensions of <code>SURFACE</code>. SDL will core dump if pixels are drawn outside a surface. It is slower, but safer to leave <code>CLIPPING</code> as <code>T</code>. </li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for READ-PIXEL-* -->


<!-- Entry for RECTANGLE -->

<p><br>[Standard class]<br><a class=none name='rectangle'><b>rectangle</b></a>
<blockquote><br>

<p>A <code>RECTANGLE</code> object manages the foreign SDL_Rect object. Free using <a href="#free">FREE</a>. </p>

</blockquote>

<!-- End of entry for RECTANGLE -->


<!-- Entry for RECTANGLE -->

<p><br>[Function]<br><a class=none name='rectangle'><b>rectangle</b> <i><tt>&amp;key</tt> x y w h fp</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates a new <code>RECTANGLE</code> from the specified <code>X</code>, <code>Y</code>, width <code>W</code> and height <code>H</code>. If <code>FP&amp;#039; is </code>NIL<code> then a foreign SDL_Rect is created. If </code>FP<code> is a pointer to a foreign SDL_Rect object then </code>FP` is used. </p>

</blockquote>

<!-- End of entry for RECTANGLE -->


<!-- Entry for RECTANGLE-* -->

<p><br>[Generic function]<br><a class=none name='rectangle-*'><b>rectangle-*</b> <i>obj</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> coordinates of the object as a spread. The <code>RESULT</code> is <code>(VALUES X Y WIDTH HEIGHT)</code> </p>

</blockquote>

<!-- End of entry for RECTANGLE-* -->


<!-- Entry for RECTANGLE-* -->

<p><br>[Method]<br><a class=none><b>rectangle-*</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the fields <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> from <code>SURFACE</code> as a spread. </p>

</blockquote>

<!-- End of entry for RECTANGLE-* -->


<!-- Entry for RECTANGLE-* -->

<p><br>[Method]<br><a class=none><b>rectangle-*</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> coordinates of the rectangle <code>RECTANGLE</code> as a spread. The <code>RESULT</code> is <code>(VALUES X Y WIDTH HEIGHT)</code> </p>

</blockquote>

<!-- End of entry for RECTANGLE-* -->


<!-- Entry for RECTANGLE-FROM-EDGES -->

<p><br>[Function]<br><a class=none name='rectangle-from-edges'><b>rectangle-from-edges</b> <i>p1 p2 <tt>&amp;optional</tt> rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#rectangle-from-edges-*">RECTANGLE-FROM-EDGES-*</a>. </p><ul><li><code>P1</code> and <code>P2</code> are <code>POINTS</code> that specify the bounds of the <code>RECTANGLE</code>. <code>P1</code> specifies the top left coordinate. <code>P2</code> specifies the lower right coordinate. </li></ul>

</blockquote>

<!-- End of entry for RECTANGLE-FROM-EDGES -->


<!-- Entry for RECTANGLE-FROM-EDGES-* -->

<p><br>[Function]<br><a class=none name='rectangle-from-edges-*'><b>rectangle-from-edges-*</b> <i>x1 y1 x2 y2 <tt>&amp;optional</tt> rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <code>RECTANGLE</code> using the bounds specified by the <code>INTEGERS</code> <code>X1</code>, <code>X2</code>, <code>Y1</code> and <code>Y2</code>. The coordinates of the rectangle are X = X1, Y = Y1, WIDTH = (- X2 X1), HEIGHT = (- Y2 Y1) </p><h5>Parameters</h5><ul><li><code>X1</code>, <code>Y1</code> specify the top left coordinate as <code>INTEGERS</code>.</li><li><code>X2</code>, <code>Y2</code> specify the bottom right coordinate as <code>INTEGERS</code>.</li><li><code>RECTANGLE</code> if unset will force the creation of a new <code>RECTANGLE</code> object. <code>RECTANGLE</code> if set will be modified with the coordinates. </li></ul>

</blockquote>

<!-- End of entry for RECTANGLE-FROM-EDGES-* -->


<!-- Entry for RECTANGLE-FROM-MIDPOINT-* -->

<p><br>[Function]<br><a class=none name='rectangle-from-midpoint-*'><b>rectangle-from-midpoint-*</b> <i>x y w h <tt>&amp;optional</tt> rectangle</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a <code>RECTANGLE</code> of width <code>W</code> and height <code>H</code> with the rectangle mid-point at coordinates <code>X</code> and <code>Y</code>. <code>RECTANGLE</code> if unset will force the creation of a new <code>RECTANGLE</code> object. <code>RECTANGLE</code> if set will be modified with the coordinates. </p>

</blockquote>

<!-- End of entry for RECTANGLE-FROM-MIDPOINT-* -->


<!-- Entry for RENDER-STRING-BLENDED -->

<p><br>[Function]<br><a class=none name='render-string-blended'><b>render-string-blended</b> <i>string <tt>&amp;key</tt> font color free cache</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Render the string <code>STRING</code> using font <code>FONT</code> with text color <code>COLOR</code> to a new <code>SURFACE</code>. The dimensions of the new surface are height == <code>FONT</code> height, and width == <code>FONT</code> width * <code>STRING</code> length. The surface background is transparent and therefore can be keyed over other surfaces. Use <code>:CACHE T</code> to cache the new surface in the <code>FONT</code> object. When <code>:FREE T</code> any exisiting cached surface in <code>FONT</code> is automatically freed. When <code>:FREE NIL</code> the caller is responsible for freeing any existing cached surface in <code>FONT</code>. </p><h5>Parameters</h5><ul><li><code>STRING</code> is the text to render.</li><li><code>FONT</code> is the font face used to render the <code>STRING</code>. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified.</li><li><code>COLOR</code> color is the text color, of type <code>COLOR</code>.</li><li><code>FREE</code> when <code>T</code> will free any exisitng cached surface in <code>FONT</code>.</li><li><code>CACHE</code> when <code>T</code> will cache the newly created SURFACE in <code>FONT</code>. Any cached surface can be accessed using <a href="#cached-surface">CACHED-SURFACE</a> and can be blitted to a target surface using <a href="#draw-font">DRAW-FONT</a>. </li></ul><h5>Returns</h5><ul><li>Returns a new cached surface <code>SDL-SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(DRAW-STRING-SOLID &quot;Hello World!&quot; :COLOR A-COLOR) </code></pre><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for RENDER-STRING-BLENDED -->


<!-- Entry for RENDER-STRING-SHADED -->

<p><br>[Function]<br><a class=none name='render-string-shaded'><b>render-string-shaded</b> <i>string fg-color bg-color <tt>&amp;key</tt> font free cache</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Render the string <code>STRING</code> using font <code>FONT</code> with text color <code>FG-COLOR</code> and background color <code>BG-COLOR</code> to a new <code>SURFACE</code>. The dimensions of the new surface are height == <code>FONT</code> height, and width == <code>FONT</code> width * <code>STRING</code> length. The surface background is filled with <code>BG-COLOR</code> so the surface cannot be keyed over other surfaces. Use <code>:CACHE T</code> to cache the new surface in the <code>FONT</code> object. When <code>:FREE T</code> any exisiting cached surface in <code>FONT</code> is automatically freed. When <code>:FREE NIL</code> the caller is responsible for freeing any existing cached surface in <code>FONT</code>. </p><h5>Parameters</h5><ul><li><code>STRING</code> is the text to render.</li><li><code>FONT</code> is the font face used to render the <code>STRING</code>. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified. </li><li><code>FG-COLOR</code> color is the text color, of type <code>COLOR</code></li><li><code>BG-COLOR</code> color is the background color used to fill the surface, of type <code>COLOR</code></li><li><code>FREE</code> when <code>T</code> will free any exisiting cached surface in <code>FONT</code>.</li><li><code>CACHE</code> when <code>T</code> will cache the newly created SURFACE in <code>FONT</code>. Any cached surface can be accessed using <a href="#cached-surface">CACHED-SURFACE</a> and can be blitted to a target surface using <a href="#draw-font">DRAW-FONT</a>. </li></ul><h5>Returns</h5><ul><li>Returns a new cached surface <code>SDL-SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(RENDER-STRING-SHADED &quot;Hello World!&quot; F-COLOR B-COLOR) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for RENDER-STRING-SHADED -->


<!-- Entry for RENDER-STRING-SOLID -->

<p><br>[Function]<br><a class=none name='render-string-solid'><b>render-string-solid</b> <i>string <tt>&amp;key</tt> font color free cache</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Render the string <code>STRING</code> using font <code>FONT</code> with text color <code>COLOR</code> to a new <code>SURFACE</code>. The dimensions of the new surface are height == <code>FONT</code> height, and width == <code>FONT</code> width * <code>STRING</code> length. The surface background is transparent and therefore can be keyed over other surfaces. Use <code>:CACHE T</code> to cache the new surface in the <code>FONT</code> object. When <code>:FREE T</code> any exisiting cached surface in <code>FONT</code> is automatically freed. When <code>:FREE NIL</code> the caller is responsible for freeing any existing cached surface in <code>FONT</code>. </p><h5>Parameters</h5><ul><li><code>STRING</code> is the text to render.</li><li><code>FONT</code> is the font face used to render the <code>STRING</code>. Of type <code>FONT</code>.  Bound to <code>*DEFAULT-FONT*</code> if unspecified.</li><li><code>COLOR</code> color is the text color, of type <code>COLOR</code>.</li><li><code>FREE</code> when <code>T</code> will free any exisitng cached surface in <code>FONT</code>.</li><li><code>CACHE</code> when <code>T</code> will cache the newly created SURFACE in <code>FONT</code>. Any cached surface can be accessed using <a href="#cached-surface">CACHED-SURFACE</a> and can be blitted to a target surface using <a href="#draw-font">DRAW-FONT</a>. </li></ul><h5>Returns</h5><ul><li>Returns a new cached surface <code>SDL-SURFACE</code>.</li></ul><h5>Example</h5><pre><code>(DRAW-STRING-SOLID &quot;Hello World!&quot; :COLOR A-COLOR) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em>, and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for RENDER-STRING-SOLID -->


<!-- Entry for RETURN-SUB-SYSTEMS-OF-STATUS -->

<p><br>[Function]<br><a class=none name='return-sub-systems-of-status'><b>return-sub-systems-of-status</b> <i>flags status</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the status <code>STATUS</code> of the the specified SDL subsystems in <code>FLAGS</code> as an INTEGER bitmask. </p><h5>Parameters</h5><ul><li><code>FLAGS</code> may contain a logior of zero or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code>, <code>SDL-INIT-NOPARACHUTE</code>. </li><li><code>STATUS</code> when <code>T</code> determines the status of initialised subsystems. <code>STATUS</code> when <code>NIL</code>, determines the status of uninitialised subsystems. </li></ul><h5>Returns</h5><ul><li>Returns an INTEGER bitmask of the SDL subsystems in <code>FLAGS</code> that are initialised when <code>STATUS</code> is <code>T</code> or uninitialised when <code>STATUS</code> is <code>NIL</code>. </li></ul>

</blockquote>

<!-- End of entry for RETURN-SUB-SYSTEMS-OF-STATUS -->


<!-- Entry for RLE-ACCEL-ENABLED-P -->

<p><br>[Generic accessor]<br><a class=none name='rle-accel-enabled-p'><b>rle-accel-enabled-p</b> <i>surface</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>rle-accel-enabled-p</b> <i>surface</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for RLE-ACCEL-ENABLED-P -->


<!-- Entry for RLE-ACCEL-ENABLED-P -->

<p><br>[Specialized accessor]<br><a class=none><b>rle-accel-enabled-p</b> <i>(surface sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>rle-accel-enabled-p</b> <i>(surface sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for RLE-ACCEL-ENABLED-P -->


<!-- Entry for ROTATE-SURFACE -->

<p><br>[Function]<br><a class=none name='rotate-surface'><b>rotate-surface</b> <i>degrees <tt>&amp;key</tt> surface free zoom smooth</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <a href="#surface">SURFACE</a> rotated to <code>DEGREES</code>. </p><h5>Parameters</h5><ul><li><code>DEGREES</code> is the rotation in degrees.</li><li><code>:SURFACE</code> is the surface to rotate <a href="#surface">SURFACE</a>.</li><li><code>:FREE</code> when <code>T</code> will free <code>SURFACE</code>.</li><li><code>:ZOOM</code> is the scaling factor.</li><li><code>:SMOOTH</code> when <code>T</code> will anti-aliase the new surface.</li></ul><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li><li><em>LISPBUILDER-SDL</em> supports rotations of only <code>0</code>, <code>90</code>, <code>180</code>, or <code>270</code> degrees. <em>LISPBUILDER-SDL-GFX</em> supports any rotation. </li><li><em>LISPBUILDER-SDL</em> ignores <code>:SMOOTH</code>. <em>LISPBUILDER-SDL-GFX</em> supports <code>:SMOOTH</code>.</li><li><em>LISPBUILDER-SDL</em> ignores <code>:ZOOM</code>. <em>LISPBUILDER-SDL-GFX</em> supports <code>:ZOOM</code>.</li><li><em>LISPBUILDER-SDL-GFX</em> ignores <code>:FREE</code>.</li></ul>

</blockquote>

<!-- End of entry for ROTATE-SURFACE -->


<!-- Entry for ROTATE-SURFACE-XY -->

<p><br>[Function]<br><a class=none name='rotate-surface-xy'><b>rotate-surface-xy</b> <i>degrees <tt>&amp;key</tt> surface free zoomx zoomy smooth</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <a href="#surface">SURFACE</a> rotated to <code>DEGREES</code>. </p><h5>Parameters</h5><ul><li><code>DEGREES</code> is the rotation in degrees.</li><li><code>:SURFACE</code> is the surface to rotate <a href="#surface">SURFACE</a>.</li><li><code>:FREE</code> when <code>T</code> will free <code>SURFACE</code>.</li><li><code>:ZOOMX</code> and <code>ZOOMY</code> are the the scaling factors. A negative scaling factor will flip the corresponding axis. <em>Note</em>: Flipping is only supported with anti-aliasing turned off. </li><li><code>:SMOOTH</code> when <code>T</code> will anti-aliase the new surface.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li><li><em>LISPBUILDER-SDL-GFX</em> ignores <code>:FREE</code>.</li></ul>

</blockquote>

<!-- End of entry for ROTATE-SURFACE-XY -->


<!-- Entry for RWOPS -->

<p><br>[Standard class]<br><a class=none name='rwops'><b>rwops</b></a>
<blockquote><br>

<p>A wrapper around a foreign SDL_RWops object. Free using <a href="#free">FREE</a>. </p>

</blockquote>

<!-- End of entry for RWOPS -->


<!-- Entry for SAVE-IMAGE -->

<p><br>[Function]<br><a class=none name='save-image'><b>save-image</b> <i>surface filename</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Saves the <code>SURFACE</code> as a <code>BMP</code> image to a file at location <code>FILENAME</code>. </p>

</blockquote>

<!-- End of entry for SAVE-IMAGE -->


<!-- Entry for SDL-ANY-FORMAT -->

<p><br>[Constant]<br><a class=none name='sdl-any-format'><b>sdl-any-format</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>;  Causes SDL to return a <a href="#display-surface">DISPLAY-SURFACE</a> of any pixel depth if the requested pixel depth is unavailable. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that the surface was created with <code>SDL-ANY-FORMAT</code>. </li></ul><p>Normally, if a <a href="#display-surface">DISPLAY-SURFACE</a> of the requested bits-per-pixel (bpp) is not available, SDL will emulate one with a shadow surface. Passing <code>SDL-ANY-FORMAT</code> prevents this and causes SDL to use the <a href="#display-surface">DISPLAY-SURFACE</a> surface, regardless of its pixel depth. </p>

</blockquote>

<!-- End of entry for SDL-ANY-FORMAT -->


<!-- Entry for SDL-ASYNC-BLIT -->

<p><br>[Constant]<br><a class=none name='sdl-async-blit'><b>sdl-async-blit</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; Enables the use of asynchronous updates of the <a href="#display-surface">DISPLAY-SURFACE</a>. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates if the surface uses asynchronous blits when possible. </li></ul><p>Asynchronous blits usually slows down blitting on single CPU machines, but may provide a speed increase on SMP systems. </p>

</blockquote>

<!-- End of entry for SDL-ASYNC-BLIT -->


<!-- Entry for SDL-BITMAP-FONT -->

<p><br>[Standard class]<br><a class=none name='sdl-bitmap-font'><b>sdl-bitmap-font</b></a>
<blockquote><br>

<p>The <code>SDL-BITMAP-FONT</code> object manages the resources for a bitmap font. Prior to the first call to a <code>RENDER-STRING*</code> function, the cached <a href="#surface">SURFACE</a> is <code>NIL</code>. </p><p>The cached surface is created by a call to any of the RENDER-STRING* functions. Use <a href="#draw-font">DRAW-FONT</a>, <a href="#draw-font-at">DRAW-FONT-AT</a> or <a href="#draw-font-at-*">DRAW-FONT-AT-*</a> to draw the cached surface. </p><p>Free using <a href="#free">FREE</a> </p>

</blockquote>

<!-- End of entry for SDL-BITMAP-FONT -->


<!-- Entry for SDL-DOUBLEBUF -->

<p><br>[Constant]<br><a class=none name='sdl-doublebuf'><b>sdl-doublebuf</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; Enable hardware double buffering; only valid with <a href="#sdl-hw-surface">SDL-HW-SURFACE</a>. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; Indicages that the surface is double buffered. </li></ul><p>Calling <a href="#sdl-flip">SDL-FLIP</a> will flip the buffers and update the screen. All drawing will take place on the surface that is not displayed at the moment. If double buffering could not be enabled then <a href="#sdl-flip">SDL-FLIP</a> will just perform a <a href="#sdl-update-rect">SDL-UPDATE-RECT</a> on the entire screen. </p>

</blockquote>

<!-- End of entry for SDL-DOUBLEBUF -->


<!-- Entry for SDL-FULLSCREEN -->

<p><br>[Constant]<br><a class=none name='sdl-fullscreen'><b>sdl-fullscreen</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; SDL will attempt to use a fullscreen mode. If a hardware resolution change is not possible (for whatever reason), the next higher resolution will be used and the display window centered on a black background. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that the surface is full-screen. </li></ul>

</blockquote>

<!-- End of entry for SDL-FULLSCREEN -->


<!-- Entry for SDL-GET-TICKS -->

<p><br>[Function]<br><a class=none name='sdl-get-ticks'><b>sdl-get-ticks</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-GET-TICKS -->


<!-- Entry for SDL-HW-ACCEL -->

<p><br>[Constant]<br><a class=none name='sdl-hw-accel'><b>sdl-hw-accel</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a> and <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a> and <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that surface blitting will use hardware acceloration. </li></ul>

</blockquote>

<!-- End of entry for SDL-HW-ACCEL -->


<!-- Entry for SDL-HW-PALETTE -->

<p><br>[Constant]<br><a class=none name='sdl-hw-palette'><b>sdl-hw-palette</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a> and <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; Gives SDL exclusive palette access to <a href="#display-surface">DISPLAY-SURFACE</a>. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that the surface has an exclusive palette. </li></ul><p>Without this flag you may not always get the the colors you request with <a href="#sdl-set-colors">SDL-SET-COLORS</a> or <a href="#sdl-set-palette">SDL-SET-PALETTE</a>. </p>

</blockquote>

<!-- End of entry for SDL-HW-PALETTE -->


<!-- Entry for SDL-HW-SURFACE -->

<p><br>[Constant]<br><a class=none name='sdl-hw-surface'><b>sdl-hw-surface</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a> and <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a> or <a href="#create-surface">CREATE-SURFACE</a>;  Create the <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a> in video memory. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates if the surface is stored in video memory. </li></ul><p>This will allow SDL to take advantage of Video-&gt;Video blits (which are often accelerated). </p>

</blockquote>

<!-- End of entry for SDL-HW-SURFACE -->


<!-- Entry for SDL-INIT-AUDIO -->

<p><br>[Constant]<br><a class=none name='sdl-init-audio'><b>sdl-init-audio</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-AUDIO -->


<!-- Entry for SDL-INIT-CDROM -->

<p><br>[Constant]<br><a class=none name='sdl-init-cdrom'><b>sdl-init-cdrom</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-CDROM -->


<!-- Entry for SDL-INIT-EVENTTHREAD -->

<p><br>[Constant]<br><a class=none name='sdl-init-eventthread'><b>sdl-init-eventthread</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-EVENTTHREAD -->


<!-- Entry for SDL-INIT-EVERYTHING -->

<p><br>[Constant]<br><a class=none name='sdl-init-everything'><b>sdl-init-everything</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-EVERYTHING -->


<!-- Entry for SDL-INIT-JOYSTICK -->

<p><br>[Constant]<br><a class=none name='sdl-init-joystick'><b>sdl-init-joystick</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-JOYSTICK -->


<!-- Entry for SDL-INIT-NOPARACHUTE -->

<p><br>[Constant]<br><a class=none name='sdl-init-noparachute'><b>sdl-init-noparachute</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-NOPARACHUTE -->


<!-- Entry for SDL-INIT-ON-STARTUP -->

<p><br>[Function]<br><a class=none name='sdl-init-on-startup'><b>sdl-init-on-startup</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if the SDL library must be initialised in <a href="#init-sdl">INIT-SDL</a>, or <a href="#with-init">WITH-INIT</a>. Returns <code>NIL</code> otherwise. </p>

</blockquote>

<!-- End of entry for SDL-INIT-ON-STARTUP -->


<!-- Entry for SDL-INIT-TIMER -->

<p><br>[Constant]<br><a class=none name='sdl-init-timer'><b>sdl-init-timer</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-TIMER -->


<!-- Entry for SDL-INIT-VIDEO -->

<p><br>[Constant]<br><a class=none name='sdl-init-video'><b>sdl-init-video</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-INIT-VIDEO -->


<!-- Entry for SDL-IYUV-OVERLAY -->

<p><br>[Constant]<br><a class=none name='sdl-iyuv-overlay'><b>sdl-iyuv-overlay</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-IYUV-OVERLAY -->


<!-- Entry for SDL-JOYSTICK-NAME -->

<p><br>[Function]<br><a class=none name='sdl-joystick-name'><b>sdl-joystick-name</b> <i>device-index</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-JOYSTICK-NAME -->


<!-- Entry for SDL-NO-FRAME -->

<p><br>[Constant]<br><a class=none name='sdl-no-frame'><b>sdl-no-frame</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; If possible, <code>SDL-NO-FRAME</code> causes SDL to create a window with no title bar or frame decoration. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; <em></em>Note: Per the SDL documentation, this is not stored in <code>FLAGS</code>. </li></ul><p>Fullscreen modes automatically have this flag set. </p>

</blockquote>

<!-- End of entry for SDL-NO-FRAME -->


<!-- Entry for SDL-OPENGL -->

<p><br>[Constant]<br><a class=none name='sdl-opengl'><b>sdl-opengl</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; Create an OpenGL rendering context. You should have previously set OpenGL video attributes with <a href="#sdl-gl-set-attribute">SDL-GL-SET-ATTRIBUTE</a>. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that the surface has an OpenGL rendering context. </li></ul>

</blockquote>

<!-- End of entry for SDL-OPENGL -->


<!-- Entry for SDL-PRE-ALLOC -->

<p><br>[Constant]<br><a class=none name='sdl-pre-alloc'><b>sdl-pre-alloc</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a>. </p><ul><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a>; Indicates that surface uses preallocated memory. </li></ul>

</blockquote>

<!-- End of entry for SDL-PRE-ALLOC -->


<!-- Entry for SDL-QUIT-ON-EXIT -->

<p><br>[Function]<br><a class=none name='sdl-quit-on-exit'><b>sdl-quit-on-exit</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns <code>T</code> if the SDL library must be uninitialised in <a href="#quit-sdl">QUIT-SDL</a>, or <a href="#with-init">WITH-INIT</a>. Returns <code>NIL</code> otherwise. </p>

</blockquote>

<!-- End of entry for SDL-QUIT-ON-EXIT -->


<!-- Entry for SDL-RESIZABLE -->

<p><br>[Constant]<br><a class=none name='sdl-resizable'><b>sdl-resizable</b></a>
<blockquote><br>

<p>Applies to <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a>; Create a resizable window. </li><li>When read from the <code>FLAGS</code> field in <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates that the surface is resizable. </li></ul><p>When the window is resized by the user a :VIDEO-RESIZE-EVENT event is generated and <a href="#window">WINDOW</a> can be called again with the new size. </p>

</blockquote>

<!-- End of entry for SDL-RESIZABLE -->


<!-- Entry for SDL-RLE-ACCEL -->

<p><br>[Constant]<br><a class=none name='sdl-rle-accel'><b>sdl-rle-accel</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a> </p><ul><li>When passed as a <code>FLAG</code> to <a href="#set-color-key">SET-COLOR-KEY</a>; The surface will be drawn using RLE acceleration when drawn with <a href="#blit-surface">BLIT-SURFACE</a>, and <a href="#draw-surface">DRAW-SURFACE</a>. The surface will actually be encoded for RLE acceleration the first time <a href="#blit-surface">BLIT-SURFACE</a>, <a href="#draw-surface">DRAW-SURFACE</a> or <a href="#convert-surface">CONVERT-SURFACE</a>  is called on the surface. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a>; Indicates that colorkey blitting is accelerated with RLE. </li></ul><p>RLE acceleration can substantially speed up blitting of images with large horizontal runs of transparent pixels (i.e., pixels that match the key color). The key must be of the same pixel format as the surface, <a href="#map-color">MAP-COLOR</a> is often useful for obtaining an acceptable value. </p>

</blockquote>

<!-- End of entry for SDL-RLE-ACCEL -->


<!-- Entry for SDL-RLE-ACCEL-OK -->

<p><br>[Constant]<br><a class=none name='sdl-rle-accel-ok'><b>sdl-rle-accel-ok</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a>. </p>

</blockquote>

<!-- End of entry for SDL-RLE-ACCEL-OK -->


<!-- Entry for SDL-SRC-ALPHA -->

<p><br>[Constant]<br><a class=none name='sdl-src-alpha'><b>sdl-src-alpha</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#create-surface">CREATE-SURFACE</a> and <a href="#set-alpha">SET-ALPHA</a>; Turns on alpha-blending for blits from this surface. If <a href="#sdl-hw-surface">SDL-HW-SURFACE</a> is also specified and alpha-blending blits are hardware-accelerated, then the surface will be placed in video memory if possible. If the screen is a hardware surface and alpha-blending blits are hardware-accelerated then the <a href="#sdl-hw-surface">SDL-HW-SURFACE</a>  flag will be set. Use <a href="#set-alpha">SET-ALPHA</a> to set or clear this flag after surface creation. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a>; Indicates that surface blitting uses alpha blending. </li></ul>

</blockquote>

<!-- End of entry for SDL-SRC-ALPHA -->


<!-- Entry for SDL-SRC-COLOR-KEY -->

<p><br>[Constant]<br><a class=none name='sdl-src-color-key'><b>sdl-src-color-key</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#create-surface">CREATE-SURFACE</a> and <a href="#set-color-key">SET-COLOR-KEY</a>; Turns on color keying for blits from this surface. If <a href="#sdl-hw-surface">SDL-HW-SURFACE</a> is also specified and color keyed blits are hardware-accelerated, then SDL will attempt to place the surface in video memory. If the screen is a hardware surface and color keyed blits are hardware-accelerated then the <a href="#sdl-hw-surface">SDL-HW-SURFACE</a> flag will be set. Use <a href="#set-color-key">SET-COLOR-KEY</a> to set or clear this flag after surface creation. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a>; Indicates that the surface uses colorkey blitting. </li></ul>

</blockquote>

<!-- End of entry for SDL-SRC-COLOR-KEY -->


<!-- Entry for SDL-SURFACE -->

<p><br>[Standard class]<br><a class=none name='sdl-surface'><b>sdl-surface</b></a>
<blockquote><br>

<p>A wrapper for the foreign SDL_Surface object. </p>

</blockquote>

<!-- End of entry for SDL-SURFACE -->


<!-- Entry for SDL-SW-SURFACE -->

<p><br>[Constant]<br><a class=none name='sdl-sw-surface'><b>sdl-sw-surface</b></a>
<blockquote><br>

<p>Applies to <a href="#surface">SURFACE</a> and <a href="#display-surface">DISPLAY-SURFACE</a>. </p><ul><li>When passed as a <code>FLAG</code> to <a href="#window">WINDOW</a> or <a href="#create-surface">CREATE-SURFACE</a>; Create the <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a> in system memory. </li><li>When read from the <code>FLAGS</code> field in <a href="#surface">SURFACE</a> or <a href="#display-surface">DISPLAY-SURFACE</a>; Indicates if the surface is stored in system memory. </li></ul><p>This improves the performance of pixel level access, however you may not be able to take advantage of some types of hardware blitting. </p>

</blockquote>

<!-- End of entry for SDL-SW-SURFACE -->


<!-- Entry for SDL-UYVY-OVERLAY -->

<p><br>[Constant]<br><a class=none name='sdl-uyvy-overlay'><b>sdl-uyvy-overlay</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-UYVY-OVERLAY -->


<!-- Entry for SDL-WM-GRAB-INPUT -->

<p><br>[Function]<br><a class=none name='sdl-wm-grab-input'><b>sdl-wm-grab-input</b> <i>mode</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-WM-GRAB-INPUT -->


<!-- Entry for SDL-YUY2-OVERLAY -->

<p><br>[Constant]<br><a class=none name='sdl-yuy2-overlay'><b>sdl-yuy2-overlay</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-YUY2-OVERLAY -->


<!-- Entry for SDL-YV12-OVERLAY -->

<p><br>[Constant]<br><a class=none name='sdl-yv12-overlay'><b>sdl-yv12-overlay</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-YV12-OVERLAY -->


<!-- Entry for SDL-YVYU-OVERLAY -->

<p><br>[Constant]<br><a class=none name='sdl-yvyu-overlay'><b>sdl-yvyu-overlay</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SDL-YVYU-OVERLAY -->


<!-- Entry for SET-CELL -->

<p><br>[Function]<br><a class=none name='set-cell'><b>set-cell</b> <i>rectangle <tt>&amp;key</tt> surface index</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>CELL</code> at <code>INDEX</code> to the bounds of <code>RECTANGLE</code>. <em>Note:</em> When <code>SURFACE</code> is the source of a blit, only the area within the cell rectangle is drawn. </p>

</blockquote>

<!-- End of entry for SET-CELL -->


<!-- Entry for SET-CELL-* -->

<p><br>[Function]<br><a class=none name='set-cell-*'><b>set-cell-*</b> <i>x y w h <tt>&amp;key</tt> surface index</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>CELL</code> at <code>INDEX</code> to a rectangle bounded by <code>X</code>, <code>Y</code>, <code>W</code> and <code>H</code>. <em>Note:</em> When <code>SURFACE</code> is the source of a blit, only the area within the cell rectangle is drawn. </p>

</blockquote>

<!-- End of entry for SET-CELL-* -->


<!-- Entry for SET-CLIP-RECT -->

<p><br>[Function]<br><a class=none name='set-clip-rect'><b>set-clip-rect</b> <i>rectangle <tt>&amp;key</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#clip-rect">CLIP-RECT</a>. </p>

</blockquote>

<!-- End of entry for SET-CLIP-RECT -->


<!-- Entry for SET-COLOR -->

<p><br>[Generic function]<br><a class=none name='set-color'><b>set-color</b> <i>dst src</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Copies the <code>RGB/A</code> color components to the destination <code>DST</code> from the source <code>SRC</code>. </p>

</blockquote>

<!-- End of entry for SET-COLOR -->


<!-- Entry for SET-COLOR -->

<p><br>[Method]<br><a class=none><b>set-color</b> <i>(dst color) (src color)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SET-COLOR -->


<!-- Entry for SET-COLOR-* -->

<p><br>[Generic function]<br><a class=none name='set-color-*'><b>set-color-*</b> <i>color <tt>&amp;key</tt> r g b a</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets <code>COLOR</code> to the red <code>R</code>, green <code>G</code>, blue <code>B</code> and alpha <code>A</code> color components. </p>

</blockquote>

<!-- End of entry for SET-COLOR-* -->


<!-- Entry for SET-COLOR-* -->

<p><br>[Method]<br><a class=none><b>set-color-*</b> <i>(color color) <tt>&amp;key</tt> r g b a</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SET-COLOR-* -->


<!-- Entry for SET-DEFAULT-FONT -->

<p><br>[Generic function]<br><a class=none name='set-default-font'><b>set-default-font</b> <i>font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the font <code>FONT</code> as the default font to be used for subsequent font rendering or drawing operations. Binds the symbol <code>*DEFAULT-FONT*</code> to font. Functions that take a <code>FONT</code> argument use <code>*DEFAULT-FONT*</code> unless otherwise specified. Returns a new <code>FONT</code>, or <code>NIL</code> if unsuccessful. </p>

</blockquote>

<!-- End of entry for SET-DEFAULT-FONT -->


<!-- Entry for SET-DEFAULT-FONT -->

<p><br>[Method]<br><a class=none><b>set-default-font</b> <i>(font bitmap-font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SET-DEFAULT-FONT -->


<!-- Entry for SET-FONT-STYLE -->

<p><br>[Function]<br><a class=none name='set-font-style'><b>set-font-style</b> <i>style <tt>&amp;key</tt> font</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the rendering style <code>STYLE</code> of font <code>FONT</code>. This will flush the internal cache of previously rendered glyphs, even if there is no change in style, so it may be best to check the  current style using <a href="#get-font-style">GET-FONT-STYLE</a> first. </p><h5>Parameters</h5><ul><li><code>FONT</code> is a <code>FONT</code> object.</li><li><code>STYLE</code> is a list of one or more: <code>:STYLE-NORMAL</code>, <code>:STYLE-BOLD</code>, <code>:STYLE-ITALIC</code>, <code>:STYLE-UNDERLINE</code>. NOTE: Combining <code>:STYLE-UNDERLINE</code> with anything  can cause a segfault, other combinations may also do this. </li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for SET-FONT-STYLE -->


<!-- Entry for SET-GL-ATTRIBUTE -->

<p><br>[Function]<br><a class=none name='set-gl-attribute'><b>set-gl-attribute</b> <i>attribute value</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SET-GL-ATTRIBUTE -->


<!-- Entry for SET-POINT -->

<p><br>[Generic function]<br><a class=none name='set-point'><b>set-point</b> <i>dst src</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Copies the <code>X</code> and <code>Y</code> coordinates to the destination <code>DST</code> from the source <code>SRC</code>. </p>

</blockquote>

<!-- End of entry for SET-POINT -->


<!-- Entry for SET-POINT -->

<p><br>[Method]<br><a class=none><b>set-point</b> <i>(dst sdl-surface) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>POINT</code> position coordinates of <code>SURFACE</code>. </p>

</blockquote>

<!-- End of entry for SET-POINT -->


<!-- Entry for SET-POINT -->

<p><br>[Method]<br><a class=none><b>set-point</b> <i>(dst rectangle) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Copies the <code>X</code> and <code>Y</code> coordinates to the destination rectangle <code>RECTANGLE</code> from the source point <code>POSITION</code>. </p>

</blockquote>

<!-- End of entry for SET-POINT -->


<!-- Entry for SET-POINT -->

<p><br>[Method]<br><a class=none><b>set-point</b> <i>(dst vector) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the destination point <code>DST</code> to the coordinates in the source point <code>SRC</code>. Returns the destination point <code>DST</code>. </p>

</blockquote>

<!-- End of entry for SET-POINT -->


<!-- Entry for SET-POINT-* -->

<p><br>[Generic function]<br><a class=none name='set-point-*'><b>set-point-*</b> <i>obj <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the object <code>OBJ</code>. <code>X</code> and <code>Y</code> are <code>KEY</code>word parameters. </p>

</blockquote>

<!-- End of entry for SET-POINT-* -->


<!-- Entry for SET-POINT-* -->

<p><br>[Method]<br><a class=none><b>set-point-*</b> <i>(obj sdl-surface) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> position coordinates of <code>SURFACE</code>. <code>X</code> and <code>Y</code> are integers. </p>

</blockquote>

<!-- End of entry for SET-POINT-* -->


<!-- Entry for SET-POINT-* -->

<p><br>[Method]<br><a class=none><b>set-point-*</b> <i>(obj rectangle) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the rectangle <code>RECTANGLE</code>. <code>X</code> and <code>Y</code> are <code>KEY</code>word parameters. </p>

</blockquote>

<!-- End of entry for SET-POINT-* -->


<!-- Entry for SET-POINT-* -->

<p><br>[Method]<br><a class=none><b>set-point-*</b> <i>(obj vector) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the point <code>POINT</code> to <code>X</code> and <code>Y</code>. </p>

</blockquote>

<!-- End of entry for SET-POINT-* -->


<!-- Entry for SET-POSITION -->

<p><br>[Generic function]<br><a class=none name='set-position'><b>set-position</b> <i>dst src</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point">SET-POINT</a> </p>

</blockquote>

<!-- End of entry for SET-POSITION -->


<!-- Entry for SET-POSITION -->

<p><br>[Method]<br><a class=none><b>set-position</b> <i>(dst sdl-surface) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point">SET-POINT</a>. </p>

</blockquote>

<!-- End of entry for SET-POSITION -->


<!-- Entry for SET-POSITION -->

<p><br>[Method]<br><a class=none><b>set-position</b> <i>(dst rectangle) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the rectangle <code>RECTANGLE</code> from the point <code>POSITION</code>. </p>

</blockquote>

<!-- End of entry for SET-POSITION -->


<!-- Entry for SET-POSITION -->

<p><br>[Method]<br><a class=none><b>set-position</b> <i>(dst vector) (src vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point">SET-POINT</a>. </p>

</blockquote>

<!-- End of entry for SET-POSITION -->


<!-- Entry for SET-POSITION-* -->

<p><br>[Generic function]<br><a class=none name='set-position-*'><b>set-position-*</b> <i>obj <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point-*">SET-POINT-*</a> </p>

</blockquote>

<!-- End of entry for SET-POSITION-* -->


<!-- Entry for SET-POSITION-* -->

<p><br>[Method]<br><a class=none><b>set-position-*</b> <i>(obj sdl-surface) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point-*">SET-POINT-*</a>. </p>

</blockquote>

<!-- End of entry for SET-POSITION-* -->


<!-- Entry for SET-POSITION-* -->

<p><br>[Method]<br><a class=none><b>set-position-*</b> <i>(obj rectangle) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code> and <code>Y</code> coordinates of the rectangle <code>RECTANGLE</code>. <code>X</code> and <code>Y</code> are <code>KEY</code>word parameters. </p>

</blockquote>

<!-- End of entry for SET-POSITION-* -->


<!-- Entry for SET-POSITION-* -->

<p><br>[Method]<br><a class=none><b>set-position-*</b> <i>(obj vector) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point-*">SET-POINT-*</a>. </p>

</blockquote>

<!-- End of entry for SET-POSITION-* -->


<!-- Entry for SET-RECTANGLE -->

<p><br>[Generic function]<br><a class=none name='set-rectangle'><b>set-rectangle</b> <i>dst src</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Copies the <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> coordinates to the destination rectangle <code>DST</code> from the source rectangle <code>SRC</code>. </p>

</blockquote>

<!-- End of entry for SET-RECTANGLE -->


<!-- Entry for SET-RECTANGLE -->

<p><br>[Method]<br><a class=none><b>set-rectangle</b> <i>(dst rectangle) (src rectangle)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Copies the <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> coordinates to the destination rectangle <code>DST</code> from the source rectangle <code>SRC</code>. </p>

</blockquote>

<!-- End of entry for SET-RECTANGLE -->


<!-- Entry for SET-RECTANGLE-* -->

<p><br>[Generic function]<br><a class=none name='set-rectangle-*'><b>set-rectangle-*</b> <i>rectangle <tt>&amp;key</tt> x y w h</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> coordinates of the rectangle <code>RECTANGLE</code>. <code>X</code>, <code>Y</code>, <code>WIDTH</code> and <code>HEIGHT</code> are <code>KEY</code>word parameters having default values of <code>0</code> if unspecified. </p>

</blockquote>

<!-- End of entry for SET-RECTANGLE-* -->


<!-- Entry for SET-RECTANGLE-* -->

<p><br>[Method]<br><a class=none><b>set-rectangle-*</b> <i>(rectangle rectangle) <tt>&amp;key</tt> x y w h</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the coordinates of the rectangle <code>RECTANGLE</code> to the specified <code>X</code>, <code>Y</code> , width <code>W</code> and height <code>HEIGHT</code> coordinates. <code>X</code>, <code>Y</code>, <code>W</code> and <code>H</code> are <code>KEY</code>word parameters of type <code>INTEGER</code>. Returns the rectangle <code>RECTANGLE</code> as RESULT. </p>

</blockquote>

<!-- End of entry for SET-RECTANGLE-* -->


<!-- Entry for SET-SURFACE -->

<p><br>[Generic function]<br><a class=none name='set-surface'><b>set-surface</b> <i>surface position</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the coordinates of the surface SURFACE to <code>POSITION</code>, where position is of type <code>POINT</code>. </p>

</blockquote>

<!-- End of entry for SET-SURFACE -->


<!-- Entry for SET-SURFACE -->

<p><br>[Method]<br><a class=none><b>set-surface</b> <i>(surface sdl-surface) (position vector)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point">SET-POINT</a>. </p>

</blockquote>

<!-- End of entry for SET-SURFACE -->


<!-- Entry for SET-SURFACE-* -->

<p><br>[Generic function]<br><a class=none name='set-surface-*'><b>set-surface-*</b> <i>surface <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets the coordinates of the surface <code>SURFACE</code>. <code>X</code> and <code>Y</code> are <code>KEY</code>word parameters having default values of <code>0</code> if unspecified. </p>

</blockquote>

<!-- End of entry for SET-SURFACE-* -->


<!-- Entry for SET-SURFACE-* -->

<p><br>[Method]<br><a class=none><b>set-surface-*</b> <i>(surface sdl-surface) <tt>&amp;key</tt> x y</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#set-point-*">SET-POINT-*</a>. </p>

</blockquote>

<!-- End of entry for SET-SURFACE-* -->


<!-- Entry for SHOW-CURSOR -->

<p><br>[Function]<br><a class=none name='show-cursor'><b>show-cursor</b> <i>state</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Disables the cursor when state is <code>NIL</code>, otherwise enables the cursor. </p>

</blockquote>

<!-- End of entry for SHOW-CURSOR -->


<!-- Entry for SIMPLE-FONT-DEFINITION -->

<p><br>[Standard class]<br><a class=none name='simple-font-definition'><b>simple-font-definition</b></a>
<blockquote><br>



</blockquote>

<!-- End of entry for SIMPLE-FONT-DEFINITION -->


<!-- Entry for SURFACE -->

<p><br>[Standard class]<br><a class=none name='surface'><b>surface</b></a>
<blockquote><br>

<p>This object is garbage collected and the <code>SDL_Surface</code> object freed when out of scope. Free using <a href="#free">FREE</a>. </p>

</blockquote>

<!-- End of entry for SURFACE -->


<!-- Entry for SURFACE-INFO -->

<p><br>[Function]<br><a class=none name='surface-info'><b>surface-info</b> <i>surface <tt>&amp;optional</tt> info</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns information about the SDL surface <code>SURFACE</code>. </p><h5>Parameters</h5><ul><li><code>SURFACE</code> is an SDL surface of type <a href="#sdl-surface">SDL-SURFACE</a>.</li><li><code>INFO</code> must be one of <code>NIL</code>, <a href="#sdl-sw-surface">SDL-SW-SURFACE</a>, <a href="#sdl-hw-surface">SDL-HW-SURFACE</a>, <a href="#sdl-async-blit">SDL-ASYNC-BLIT</a>, <a href="#sdl-any-format">SDL-ANY-FORMAT</a>, <a href="#sdl-hw-palette">SDL-HW-PALETTE</a>, <a href="#sdl-doublebuf">SDL-DOUBLEBUF</a>, <a href="#sdl-fullscreen">SDL-FULLSCREEN</a>, <a href="#sdl-opengl">SDL-OPENGL</a>, <a href="#sdl-resizable">SDL-RESIZABLE</a> <a href="#sdl-hw-accel">SDL-HW-ACCEL</a>, <a href="#sdl-src-color-key">SDL-SRC-COLOR-KEY</a>, <a href="#sdl-rle-accel">SDL-RLE-ACCEL</a>, <a href="#sdl-src-alpha">SDL-SRC-ALPHA</a>  or <a href="#sdl-pre-alloc">SDL-PRE-ALLOC</a>. </li></ul><h5>Returns</h5><p><code>INFO</code> when <code>NIL</code> will return a list of all enabled surface flags. Otherwise will return <code>INFO</code> as <code>T</code> or <code>NIL</code> if supported by the surface. </p><h5>Example</h5><pre><code>(SURFACE-INFO A-SURFACE &#039;(SDL-HW-SURFACE SDL-HW-PALETTE SDL-HW-ACCELL)) </code></pre>

</blockquote>

<!-- End of entry for SURFACE-INFO -->


<!-- Entry for TIME-SCALE -->

<p><br>[Function]<br><a class=none name='time-scale'><b>time-scale</b> <i><tt>&amp;optional</tt> fpsmanager</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for TIME-SCALE -->


<!-- Entry for TO-DEGREE -->

<p><br>[Function]<br><a class=none name='to-degree'><b>to-degree</b> <i>radian</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Converts radians to degrees. </p>

</blockquote>

<!-- End of entry for TO-DEGREE -->


<!-- Entry for TO-RADIAN -->

<p><br>[Function]<br><a class=none name='to-radian'><b>to-radian</b> <i>degree</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Converts degrees to radians. </p>

</blockquote>

<!-- End of entry for TO-RADIAN -->


<!-- Entry for UPDATE-DISPLAY -->

<p><br>[Function]<br><a class=none name='update-display'><b>update-display</b> <i><tt>&amp;optional</tt> surface</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>When <a href="#opengl-context">OPENGL-CONTEXT</a> is <code>NIL</code>; <code>UPDATE-DISPLAY</code> will flip the SDL video buffers and update the screen <code>SURFACE</code> if <code>SDL-HW-SURFACE</code> is set in <a href="#window">WINDOW</a>. If double buffering is not enabled then  SDL will perform an <a href="#sdl-update-rect">SDL-UPDATE-RECT</a> on the entire screen. </p><p>When <a href="#opengl-context">OPENGL-CONTEXT</a> is <code>T</code>; <code>UPDATE-DISPLAY</code> will call <a href="#sdl-gl-swap-buffers">SDL-GL-SWAP-BUFFERS</a> to update the OpenGL display context. </p><p><code>SURFACE</code> is bound to <code>*DEFAULT-DISPLAY*</code> if unspecified. </p>

</blockquote>

<!-- End of entry for UPDATE-DISPLAY -->


<!-- Entry for UPDATE-INPUT-UTIL -->

<p><br>[Function]<br><a class=none name='update-input-util'><b>update-input-util</b> <i>time</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>This must be called once for each time period you are updating the application, in order to update keypress information. </p><h5>Parameters</h5><ul><li><code>TIME</code> is the time in seconds this update represents</li></ul><h5>Returns</h5>

</blockquote>

<!-- End of entry for UPDATE-INPUT-UTIL -->


<!-- Entry for UPDATE-SURFACE -->

<p><br>[Function]<br><a class=none name='update-surface'><b>update-surface</b> <i>surface <tt>&amp;optional</tt> template</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Updates the surface </p>

</blockquote>

<!-- End of entry for UPDATE-SURFACE -->


<!-- Entry for UPDATE-SURFACE-* -->

<p><br>[Function]<br><a class=none name='update-surface-*'><b>update-surface-*</b> <i>surface x y w h</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>See <a href="#update-surface">UPDATE-SURFACE</a>. </p>

</blockquote>

<!-- End of entry for UPDATE-SURFACE-* -->


<!-- Entry for VIDEO-DIMENSIONS -->

<p><br>[Function]<br><a class=none name='video-dimensions'><b>video-dimensions</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the best video dimensions if called before a window is created, using <a href="#window">WINDOW</a>. Returns the current video dimensions if called after a window is created. Must be called after SDL is initialized using <a href="#init-sdl">INIT-SDL</a> or <a href="#with-init">WITH-INIT</a> </p>

</blockquote>

<!-- End of entry for VIDEO-DIMENSIONS -->


<!-- Entry for VIDEO-DRIVER-NAME -->

<p><br>[Function]<br><a class=none name='video-driver-name'><b>video-driver-name</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the driver name of the initialised video driver. The driver name is a <code>STRING</code> containing a one-word identifier like &quot;x11&quot; or &quot;windib&quot;. Returns &#039;NIL&#039; if the video driver is not already initialised with <a href="#init-sdl">INIT-SDL</a> or <a href="#with-init">WITH-INIT</a>. </p><h5>Example</h5><pre><code>(sdl:with-init ()  
  (sdl:video-driver-name)) &gt;&gt; &quot;windib&quot; </code></pre>

</blockquote>

<!-- End of entry for VIDEO-DRIVER-NAME -->


<!-- Entry for VIDEO-INFO -->

<p><br>[Function]<br><a class=none name='video-info'><b>video-info</b> <i><tt>&amp;optional</tt> info</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns information about the video hardware. <code>GET-VIDEO-INFO</code> must be called after SDL is initialised using <a href="#init-sdl">INIT-SDL</a> or <a href="#with-init">WITH-INIT</a>. If <code>GET-VIDEO-INFO</code> is called before <a href="#window">WINDOW</a>, the information returned is of the <em>best</em> video mode. If <code>GET-VIDEO-INFO</code> is called after <a href="#window">WINDOW</a>, the information returned is of the <em>current</em> video mode. </p><h5>Parameters</h5><ul><li><code>INFO</code> can be one of <code>:HW-AVAILABLE</code>, <code>:WM-AVAILABLE</code>, <code>:BLIT-HW</code>, <code>:BLIT-HW-CC</code>, <code>:BLIT-HW-A</code>, <code>:BLIT-SW</code>, <code>:BLIT-SW-CC</code>, <code>:BLIT-SW-A</code>or <code>:BLIT-FILL</code>. If <code>NIL</code>, returns a list of all supported video flags. </li></ul><h5>Example</h5><pre><code>(video-info :HW-AVAILABLE) </code></pre>

</blockquote>

<!-- End of entry for VIDEO-INFO -->


<!-- Entry for VIDEO-MEMORY -->

<p><br>[Function]<br><a class=none name='video-memory'><b>video-memory</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the amount of video memory of the graphics hardware. Must be called after SDL is initialized using <a href="#init-sdl">INIT-SDL</a> or <a href="#with-init">WITH-INIT</a>. </p>

</blockquote>

<!-- End of entry for VIDEO-MEMORY -->


<!-- Entry for WIDTH -->

<p><br>[Generic accessor]<br><a class=none name='width'><b>width</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>width</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WIDTH -->


<!-- Entry for WIDTH -->

<p><br>[Method]<br><a class=none><b>width</b> <i>(obj font)</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WIDTH -->


<!-- Entry for WIDTH -->

<p><br>[Method]<br><a class=none><b>width</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns the width of <code>SURFACE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for WIDTH -->


<!-- Entry for WIDTH -->

<p><br>[Specialized accessor]<br><a class=none><b>width</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>width</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>INTEGER</code> width of the rectangle <code>RECTANGLE</code>. </p>

</blockquote>

<!-- End of entry for WIDTH -->


<!-- Entry for WINDOW -->

<p><br>[Function]<br><a class=none name='window'><b>window</b> <i>width height <tt>&amp;key</tt> bpp flags title-caption icon-caption</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates a new SDL window of pixel width <code>WIDTH</code> and height <code>HEIGHT</code> using SDL_SetVideoMode. </p><p>Use <code>SDL-SW-SURFACE</code> if you plan on doing per-pixel manipulations, or blit surfaces with alpha channels, and require a high framerate. When you use hardware surfaces like <code>SDL-HW-SURFACE</code>, SDL copies the surfaces from video memory to system memory when you lock them, and back when you unlock them. This can cause a major performance hit. (Be aware that you may request a hardware surface, but receive a software surface. Many platforms can only provide a hardware surface when using <code>SDL-FULL-SCREEN.) </code>SDL-HW-SURFACE` is best used when the surfaces you&#039;ll be blitting can also be stored in video memory. </p><p><em>Note:</em> To control the position on the screen when creating a windowed surface, set the environment variables <code>SDL_VIDEO_CENTERED=center</code> or <code>SDL_VIDEO_WINDOW_POS=x,y</code>. These may be set using <a href="#sdl-put-env">SDL-PUT-ENV</a>. </p><h5>Parameters</h5><ul><li><code>WIDTH</code> the pixel width of the window, of type <code>INTEGER</code>.</li><li><code>HEIGHT</code> the pixel height of the window, of type <code>INTEGER</code>. If <code>WIDTH</code> and <code>HEIGHT</code> are both <code>0</code>, then the width and height of the current video mode is used (or the desktop mode, if no mode has been set). </li><li><code>BPP</code> the number of bits per pixel. Defaults to <code>0</code> which is the current display bits per pixel. <em>Note:</em> A <code>BPP</code> of <code>24</code> uses the packed representation of 3 bytes/pixel. For the more common 4 bytes/pixel mode, use a <code>BPP</code> of 32. </li><li><code>FLAGS</code> is a bitmasked logior of one or more of the following; <a href="#sdl-sw-surface">SDL-SW-SURFACE</a>, <a href="#sdl-hw-surface">SDL-HW-SURFACE</a>, <a href="#sdl-async-blit">SDL-ASYNC-BLIT</a>, <a href="#sdl-any-format">SDL-ANY-FORMAT</a>, <a href="#sdl-hw-palette">SDL-HW-PALETTE</a>, <a href="#sdl-doublebuf">SDL-DOUBLEBUF</a>, <a href="#sdl-fullscreen">SDL-FULLSCREEN</a>, <a href="#sdl-opengl">SDL-OPENGL</a>, <a href="#sdl-resizable">SDL-RESIZABLE</a> and <a href="#SDL-NO-FRAME">SDL-NO-FRAME</a>. </li><li><code>TITLE-CAPTION</code> is the title that appears in the Window title bar, of type <code>STRING</code>.</li><li><code>ICON-CAPTION</code> is the title that appears when the Window is minimized, of type <code>STRING</code>.</li></ul><h5>Returns</h5><ul><li>Returns a new <code>DISPLAY-SURFACE</code> if successful, <code>NIL</code> if unsuccessful. Whatever flags SDL_SetVideoMode could satisfy are set in the flags member of <code>SURFACE</code>. The <code>SURFACE</code> returned is freed by SDL and should never be freed by the caller. This rule includes consecutive calls to <code>WINDOW</code> (i.e. upon resize or resolution change) - any existing surface will be released automatically by SDL. </li></ul><h5>Example</h5><pre><code>(WINDOW 320 240 :TITLE-CAPTION &quot;Random-Rects&quot; :ICON-CAPTION &quot;Random-Rects&quot;  
                 :FLAGS &#039;(SDL-DOUBLEBUF SDL-FULLSCREEN)) </code></pre>

</blockquote>

<!-- End of entry for WINDOW -->


<!-- Entry for WITH-BEZIER -->

<p><br>[Macro]<br><a class=none name='with-bezier'><b>with-bezier</b> <i>(<tt>&amp;optional</tt> style segments) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a bezier curve of <code>*DEFAULT-COLOR*</code> to <code>*DEFAULT-SURFACE*</code>. The shape of the Bezier curve is defined by control points. A control point is a vertex containing an X and Y coordinate pair. </p><p>The number of segments <code>SEGENTS</code> used to draw the Bezier curve defaults to 10. The greater the number of segments, the smoother the Bezier curve. </p><h5>Local Methods</h5><p>A vertex may be added using: </p><ul><li><code>ADD-VERTEX</code> which accepts an <code>POINT</code>, or</li><li><code>ADD-VERTEX-*</code> which is the x/y spread version</li></ul><p><code>ADD-VERTEX</code> and <code>ADD-VERTEX-*</code> are valid only within the scop of <code>WITH-BEZIER</code>. </p><h5>Parameters</h5><ul><li><code>STYLE</code> is one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. When <code>STYLE</code> is <code>:SOLID</code>, a single continuous line is drawn through the specified waypoints. When <code>STYLE</code> is <code>:DASH</code>, a line is drawn to alternate waypoint pairs. When <code>STYLE</code> is <code>:POINTS</code>, a single point is drawn at each waypoint. </li><li><code>SEGMENTS</code> is the number of segments used to draw the Bezier curve. Default is 20 segments if unspecified. The greater the number of segments, the smoother the curve. </li></ul><h5>Example</h5><pre><code>(SDL:WITH-COLOR (COL (SDL:COLOR))  
   (WITH-BEZIER ()  
     (ADD-VERTEX-* 60  40)  
     (ADD-VERTEX-* 160 10)  
     (ADD-VERTEX-* 170 150)  
     (ADD-VERTEX-* 60  150))) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for WITH-BEZIER -->


<!-- Entry for WITH-COLOR -->

<p><br>[Macro]<br><a class=none name='with-color'><b>with-color</b> <i>(var <tt>&amp;optional</tt> color free) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>A convience macro that binds <code>*DEFAULT-COLOR*</code> to <code>VAR</code> within the scope of <code>WITH-COLOR</code>. <code>VAR</code> is set to <code>COLOR</code> when <code>COLOR</code> is not <code>NIL</code>.<code>VAR</code> must be of type <a href="#color">COLOR</a>, or <a href="#color-a">COLOR-A</a>. <code>VAR</code> is freed using <a href="#free">FREE</a> when <code>FREE</code> is <code>T</code>. </p>

</blockquote>

<!-- End of entry for WITH-COLOR -->


<!-- Entry for WITH-CURVE -->

<p><br>[Macro]<br><a class=none name='with-curve'><b>with-curve</b> <i>(<tt>&amp;optional</tt> style segments) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a Cattmul-Rom spline of <code>*DEFAULT-COLOR*</code> to <code>*DEFAULT-SURFACE*</code>. The shape of the curve is defined by waypoints. A waypoint is a vertex containing an X and Y coordinate pair. </p><h5>Local Methods</h5><p>A vertex may be added using: </p><ul><li><code>ADD-VERTEX</code> which accepts an <code>SDL:POINT</code>, or</li><li><code>ADD-VERTEX-*</code> which is the x/y spread version</li></ul><p><code>ADD-VERTEX</code> and <code>ADD-VERTEX-*</code> are valid only within the scope of <code>WITH-CURVE</code>. </p><h5>Parameters</h5><ul><li><code>STYLE</code> describes the line style used to draw the curve and may be one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. Use <code>:SOLID</code> to draw a single continuous line through the specified waypoints. Use <code>:DASH</code> to draw a line between alternate waypoint pairs. Use <code>:POINTS</code> to draw a single pixel at each waypoint. </li><li><code>SEGMENTS</code> is the number of segments used to draw the Catmull-Rom spline. Default is 20 segments if unspecified. The greater the number of segments, the smoother the spline. </li></ul><h5>Example</h5><pre><code>(SDL:WITH-COLOR (COL (SDL:COLOR))  
   (WITH-CURVE (:SOLID 30)  
     (ADD-VERTEX-* 60  40)  
     (ADD-VERTEX-* 160 10)  
     (ADD-VERTEX-* 170 150)  
     (ADD-VERTEX-* 60  150))) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for WITH-CURVE -->


<!-- Entry for WITH-DEFAULT-FONT -->

<p><br>[Macro]<br><a class=none name='with-default-font'><b>with-default-font</b> <i>(font) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets <code>*DEFAULT-FONT*</code> to <code>FONT</code> within the scope of <code>WITH-DEFAULT-FONT</code>. </p><h5>Example</h5><pre><code>(WITH-DEFAULT-FONT (new-font)  
    (DRAW-CHARACTER-SHADED-* &quot;Hello World!&quot; 0 0 F-COLOR B-COLOR)) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em> and <em>LISPBUILDER-SDL-TTF</em></li></ul>

</blockquote>

<!-- End of entry for WITH-DEFAULT-FONT -->


<!-- Entry for WITH-EVENTS -->

<p><br>[Macro]<br><a class=none name='with-events'><b>with-events</b> <i>(<tt>&amp;optional</tt> type) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p><code>WITH-EVENTS</code> is a convenience macro for managing the main game loop. It processes incoming SDL events and limits the game loop to the specified number of frames per second. </p><p>Both the <a href="#sdl-poll-event">SDL-POLL-EVENT</a> and <a href="#sdl-wait-event">SDL-WAIT-EVENT</a> event mechanisms are supported by specifying the <code>TYPE</code> as <code>:POLL</code> or <code>:WAIT</code> respectively. </p><p><em>NOTE:</em> <code>WITH-EVENTS</code> must be called in the same thread used to set the video mode. </p><h5>Example</h5><pre><code>(SDL:WITH-EVENTS (:POLL)  
  (:QUIT-EVENT () T)  
  (:KEY-DOWN-EVENT (:KEY KEY)  
      (WHEN (SDL:KEY= KEY :SDL-KEY-ESCAPE)  
        (SDL:PUSH-QUIT-EVENT)))  
  (:VIDEO-EXPOSE-EVENT () (SDL:UPDATE-DISPLAY)))))) </code></pre><h5>Frame Rate Limiting</h5><p>The frame rate is specified using <a href="#frame-rate">FRAME-RATE</a>. For example to set the frame rate to 60 frames per second: </p><pre><code>(SETF (SDL:FRAME-RATE) 60) </code></pre><h5>Event Syntax</h5><p>Events are specified using the format <code>(:EVENT-TYPE (&amp;amp;KEYS KEYS))</code> </p><ul><li><code>EVENT-TYPE</code> must be one of the following <code>KEY</code>words; <code>:ACTIVE-EVENT, :KEY-DOWN-EVENT, :KEY-UP-EVENT, :MOUSE-MOTION-EVENT, :MOUSE-BUTTON-DOWN-EVENT, :MOUSE-BUTTON-UP-EVENT, :JOY-AXIS-MOTION-EVENT, :JOY-BUTTON-DOWN-EVENT, :JOY-BUTTON-UP-EVENT, :JOY-HAT-MOTION-EVENT, :JOY-BALL-MOTION-EVENT, :VIDEO-RESIZE-EVENT, :VIDEO-EXPOSE-EVENT, :SYS-WM-EVENT, :QUIT-EVENT, :USER-EVENT</code> or <code>:IDLE</code>. </li><li><code>KEYS</code> specify the members of the event to return and are specific to each event type. These are discussed in detail below. </li></ul><p><em>NOTE:</em> <code>:QUIT-EVENT</code> must return <code>T</code> to exit the <code>WITH-EVENT</code> macro. </p><p><em>NOTE:</em> <code>:IDLE</code> is ignored when <code>TYPE</code> is <code>:WAIT</code>. </p><h5>Polling for Events</h5><p>When <code>TYPE</code> is <code>:POLL</code>, <code>WITH-EVENTS</code> will continually poll for currently pending events. If no events are available then the game loop is run and the forms in <code>:IDLE</code> are executed. </p><h5>Waiting for Events</h5><p>When <code>TYPE</code> is <code>:WAIT</code>, <code>WITH-EVENTS</code> will sleep indefinitely for the next available event. If no events are available then the game loop is paused. </p><h5>The :IDLE Event</h5><pre><code> (:IDLE ()  
    &amp;BODY BODY) </code></pre><p>The <code>:IDLE</code> event is special in that it is not generated by SDL. Rather the forms  in <code>:IDLE</code> are executed once each game loop after event queue is emptied. <code>:IDLE</code> is ignored when the event mechanism specified by <code>TYPE</code> is <code>:WAIT</code>. </p><h5>Active Event</h5><pre><code>(:ACTIVE-EVENT (:GAIN GAIN :STATE STATE)  
   &amp;BODY BODY) </code></pre><p>When the mouse leaves or enters the window area an <code>SDL-APP-MOUSE-FOCUS</code> type activation event is generated.<br />
 If the mouse has entered the window then <code>GAIN</code> will be <code>1</code>, otherwise <code>GAIN</code> will be <code>0</code>.  An <code>SDL-APP-INPUT-FOCUS</code> type activation event occurs when the application loses or gains keyboard focus, usually when a different application is made active. Finally, an <code>SDL-APP-ACTIVE</code> type event occurs when the application is either minimised/iconified, <code>GAIN</code> is <code>0</code>, or restored. A single event can have multiple values set in <code>STATE</code>. <em>Note:</em> This event does not occur when an application window is first created. </p><ul><li><code>GAIN</code> is <code>0</code> if the event is a loss or <code>1</code> if it is a gain.</li><li><code>STATE</code> a bitmask of the following values: <code>SDL-APP-MOUSE-FOCUS</code> if mouse focus was gained or lost, <code>SDL-APP-INPUT-FOCUS</code> if input focus was gained or lost, and <code>SDL-APP-ACTIVE</code> if the application was iconified, <code>GAIN</code> is <code>0</code>, or restored <code>GAIN</code> is <code>1</code>. </li></ul><h5>Keyboard Events</h5><pre><code>(:KEY-DOWN-EVENT (:STATE STATE :SCANCODE SCANCODE :KEY KEY :MOD MOD :UNICODE UNICODE)  
   &amp;BODY BODY)  
(:KEY-UP-EVENT (:STATE STATE :SCANCODE SCANCODE :KEY KEY :MOD MOD :UNICODE UNICODE)  
   &amp;BODY BODY) </code></pre><p>A keyboard event generally occurs when a key is released or when a key is pressed. The information on the key that generated the event is stored in <code>KEY</code> and <code>MOD</code>. </p><p>The <code>SDL-CAPS-LOCK</code> and <code>SDL-NUM-LOCK</code> keys are special cases and report an <code>SDL-KEY-DOWN</code> when first pressed, then an <code>SDL-RELEASED</code> when released and pressed again. These keys KEYUP and KEYDOWN events are therefore analogous to the state of  the caps lock and num lock LEDs rather than the keys themselves. These special  cases are required for compatibility with Sun workstations. </p><p><em>Note:</em> Repeating <code>SDL-KEY-DOWN</code> events will occur if key repeat is enabled using <a href="#sdl-enable-key-repeat">SDL-ENABLE-KEY-REPEAT</a>. </p><ul><li><code>STATE</code> is <code>SDL-PRESSED</code> or <code>SDL-RELEASED</code> if the key is pressed or released respectively.</li><li><code>SCANCODE</code> is the hardware-dependent scancode returned by the keyboard.</li><li><code>KEY</code> is is the SDL-defined value of the key that generated the event. The SDL-defined value for <code>KEY</code> generally takes the following format: <code>:SDL-KEY-0</code> to <code>:SDL-KEY-1</code> for numeric keys. <code>SDL-KEY-a</code> to <code>SDL-KEY-z</code> for alpha keys in the range a-z. Other keys are generally spelled out, for example <code>SDL-KEY-PAGEDOWN</code>, <code>SDL-KEY-F1</code> or <code>SDL-KEY-NUMLOCK</code> . </li><li><code>MOD</code> is current state of the keyboard modifiers as explained in SDL_GetModState. One or more of <code>:SDL-KEY-MOD-NONE, :SDL-KEY-MOD-LSHIFT, :SDL-KEY-MOD-RSHIFT, :SDL-KEY-MOD-LCTRL, :SDL-KEY-MOD-RCTRL, :SDL-KEY-MOD-LALT, :SDL-KEY-MOD-RALT, :SDL-KEY-MOD-LMETA, :SDL-KEY-MOD-RMETA, :SDL-KEY-MOD-NUM, :SDL-KEY-MOD-CAPS, :SDL-KEY-MOD-MODE or :SDL-KEY-MOD-RESERVED</code>. </li><li><code>UNICODE</code> is the translated character. The unicode field is only used when UNICODE translation is enabled with SDL_EnableUNICODE. If unicode is non-zero then this is the UNICODE character corresponding to the keypress. If the high 9 bits of the character are 0, then this maps to the equivalent ASCII character. </li></ul><h5>Mouse Motion Event</h5><pre><code>(:MOUSE-MOTION-EVENT (:STATE STATE :X X :Y Y :X-REL X-REL :Y-REL Y-REL)  
   &amp;BODY BODY) </code></pre><p>A <code>MOUSE-MOTION-EVENT</code> event occurs when the mouse moves within the application window or when <a href="#SDL-WARP-MOUSE">SDL-WARP-MOUSE</a> is called. Both the absolute <code>X</code> and <code>Y</code> and relative <code>X-REL</code> and <code>Y-REL</code> coordinates are reported along with the current button state <code>STATE</code>. The button state can be interpreted using <a href="#sdl-button">SDL-BUTTON</a>, see <a href="#sdl-get-mouse-state">SDL-GET-MOUSE-STATE</a>. </p><p>If the cursor is hidden using <a href="#sdl-show-cursor">SDL-SHOW-CURSOR</a> and the input is grabbed using <a href="#sdl-wm-grab-input">SDL-WM-GRAB-INPUT</a>, then the mouse will give relative motion events even when the cursor reaches the edge of the screen. This is currently only implemented on Windows and Linux/Unix-alikes. </p><ul><li><code>STATE</code> is the current button state.</li><li><code>X</code> is the <code>X</code> coordinates of the mouse</li><li><code>Y</code> is the <code>Y</code> coordinates of the mouse</li><li><code>X-REL</code> is the relative motion in the <code>X</code> direction</li><li><code>Y-REL</code> is the relative motion in the <code>Y</code> direction</li></ul><h5>Mouse Button Events</h5><pre><code> (:MOUSE-BUTTON-DOWN-EVENT (:BUTTON BUTTON :STATE STATE :X X :Y Y)  
   &amp;BODY BODY)  
 (:MOUSE-BUTTON-UP-EVENT (:BUTTON BUTTON :STATE STATE :X X :Y Y)  
   &amp;BODY BODY) </code></pre><p>When a mouse button press or release is detected the number of the button pressed (from 1 to 255, with 1 usually being the left button and 2 the right) is placed into <code>BUTTON</code>, the position of the mouse when this event occured is stored in the <code>X</code> and the <code>Y</code> fields. </p><p>Mouse wheel events are reported as buttons 4 (up) and 5 (down). Two events are generated i.e. a <code>SDL-MOUSE-BUTTON-DOWN</code> followed by a <code>SDL-MOUSE-BUTTON-UP</code> event. </p><ul><li><code>BUTTON</code> is the mouse button index which is one of <code>SDL-BUTTON-LEFT</code>, <code>SDL-BUTTON-MIDDLE</code>, <code>SDL-BUTTON-RIGHT</code>, <code>SDL-BUTTON-WHEELUP</code> or <code>SDL-BUTTON-WHEELDOWN</code>. </li><li><code>STATE</code> is the state of the button which is <code>SDL-PRESSED</code> or <code>SDL-RELEASED</code>.</li><li><code>X</code> is the <code>X</code> coordinates of the mouse at press/release time.</li><li><code>Y</code> is the <code>Y</code> coordinates of the mouse at press/release time.</li></ul><h5>Joystick Motion Event</h5><pre><code>(:JOY-AXIS-MOTION-EVENT (:WHICH WHICH :AXIS AXIS :VALUE VALUE)  
   &amp;BODY BODY) </code></pre><p>A JOY-AXIS-MOTION-EVENT event occurs whenever a user moves an axis on the joystick. </p><ul><li><code>WHICH</code> is the joystick device index. The index of the joystick that reported the event.</li><li><code>AXIS</code> is the joystick axis index</li><li><code>VALUE</code> is the current position of the axis (range: -32768 to 32767)</li></ul><h5>Joystick Button Events</h5><pre><code>(:JOY-BUTTON-DOWN-EVENT (:WHICH WHICH :BUTTON BUTTON :STATE STATE)  
   &amp;BODY BODY)  
(:JOY-BUTTON-UP-EVENT (:WHICH WHICH :BUTTON BUTTON :STATE STATE)  
   &amp;BODY BODY) </code></pre><p>A <code>JOY-BUTTON-DOWN-EVENT</code> or <code>JOY-BUTTON-DOWN-EVENT</code> event occurs whenever a user presses or releases a button on a joystick. <br />
</p><ul><li><code>WHICH</code> is the index of the joystick that reported the event.</li><li><code>BUTTON</code> is the button pressed that caused the event.</li><li><code>STATE</code> is the current state of the button and is either <code>SDL-PRESSED</code> or <code>SDL-RELEASED</code>. </li></ul><h5>Joystick Hat Motion Event</h5><pre><code>   (:JOY-HAT-MOTION-EVENT (:WHICH WHICH :HAT HAT :VALUE VALUE)  
     &amp;BODY BODY) </code></pre><p>A <code>JOY-HAT-MOTION-EVENT</code> event occurs when ever a user moves a hat on the joystick. </p><ul><li><code>WHICH</code> is the index of the joystick that reported the event.</li><li><code>HAT</code> is the index of the hat that generated the event.</li><li><code>VALUE</code> is the current position of the hat, a bitwise OR&#039;d combination of the following values <code>SDL-HAT-CENTERED</code>, <code>SDL-HAT-UP</code>, <code>SDL-HAT-RIGHT</code>, <code>SDL-HAT-DOWN</code>, <code>SDL-HAT-LEFT</code>, <code>SDL-HAT-RIGHT-UP</code>, <code>SDL-HAT-RIGHT-DOWN</code>, <code>SDL-HAT-LEFT-UP</code> and <code>SDL-HAT-LEFT-DOWN</code>. </li></ul><h5>Joystick Ball Motion Event</h5><pre><code>(:JOY-BALL-MOTION-EVENT (:WHICH WHICH :BALL BALL :X-REL X-REL :Y-REL Y-REL)  
  &amp;BODY BODY) </code></pre><p>A <code>JOY-BALL-MOTION-EVENT</code> event occurs when a user moves a trackball on the joystick. Trackballs only return relative motion. </p><ul><li><code>WHICH</code> is the index of the joystick that reported the event.</li><li><code>BALL</code> is the index of the trackball that generated the event.</li><li><code>X-REL</code> is the change in <code>X</code> position of the ball since it was last polled (last cycle of the event loop). </li><li><code>Y-REL</code> is the change in <code>Y</code> position of the ball since it was last polled (last cycle of the event loop). </li></ul><h5>Quit Event</h5><pre><code>(:QUIT-EVENT ()  
   &amp;BODY BODY) </code></pre><p>If <code>QUIT-EVENT</code> is filtered or ignored then it is impossible for the user to close the window. If <code>QUIT-EVENT</code> is accepted and returns <code>T</code> then the application window will be closed. <em>Note:</em> Screen updates will continue to report success even though the application is no longer visible. If <code>QUIT-EVENT</code> is accepted and returns <code>NIL</code> then the application window will <em>not</em> be closed. <a href="#sdl_quit-requested">SDL_QUIT-REQUESTED</a> will return non-zero if a <code>QUIT-EVENT</code> event is pending. </p><h5>SDL Window Resize Event</h5><pre><code>(:VIDEO-RESIZE-EVENT (:W W :H H)  
   ...) </code></pre><p>When <code>SDL-RESIZABLE</code> is passed as a flag to <a href="#window">WINDOW</a>, the user is allowed to resize the application window. When the window is resized a <code>VIDEO-RESIZE-EVENT</code> event is reported, with the new window width and height values stored in <code>W</code> and <code>H</code> respectively. When an <code>VIDEO-RESIZE-EVENT</code> event is recieved the window should be resized to the new dimensions using <a href="#window">WINDOW</a>. </p><ul><li><code>W</code> is the window width as an <code>INTEGER</code>.</li><li><code>H</code> is the window height as an INTERGER`.</li></ul><h5>SDL Window Expose Event</h5><pre><code>(:VIDEO-EXPOSE-EVENT ()  
   ...) </code></pre><p><code>VIDEO-EXPOSE-EVENT</code> is triggered when the screen has been modified outside of the application, usually by the window manager, and needs to be redrawn. </p><h5>System Window Events</h5><pre><code>(:SYS-WM-EVENT ()  
   ...) </code></pre><p>The system window manager event contains a pointer to system-specific information about unknown window manager events. If this event is enabled using <a href="#sdl-event-state">SDL-EVENT-STATE</a>, it will be generated whenever unhandled events are received from the window manager. This can be used, for example, to implement cut-and-paste in your application. If you want to obtain system-specific information about the window manager, you can fill in the version member of a <code>SDL-SYS-WM-INFO</code> structure using <a href="#sdl-version">SDL-VERSION</a>, and pass it to the function: <a href="#sdl-get-wm-info">SDL-GET-WM-INFO</a> </p><h5>User</h5><pre><code>(:USER-EVENT (:TYPE TYPE :CODE CODE :DATA1 DATA1 :DATA2 DATA2)  
   ...) </code></pre><p><code>USER-EVENT</code> is unique in that it is created by the user not SDL. <code>USER-EVENT</code> can be pushed onto the event queue using <a href="#push-user-event">PUSH-USER-EVENT</a>. The contents of the event are completely up to the programmer. </p><ul><li><code>TYPE</code> is  a value from <code>SDL-USER-EVENT to </code>(- SDL-NUM-EVENTS 1)` inclusive.</li><li><code>CODE</code> is a user defined event code</li><li><code>DATA1</code> is a user defined data pointer</li><li><code>DATA2</code> is a user defined data pointer</li></ul><h5>Syntax</h5><pre><code>(WITH-EVENTS (TYPE)  
 (:ACTIVE-EVENT (:GAIN GAIN :STATE STATE)  
    ... )  
 (:KEY-DOWN-EVENT (:STATE STATE :SCANCODE SCANCODE :KEY KEY :MOD MOD :UNICODE UNICODE)  
    ... )  
 (:KEY-UP-EVENT (:STATE STATE :SCANCODE SCANCODE :KEY KEY :MOD MOD :UNICODE UNICODE)  
    ...)  
 (:MOUSE-MOTION-EVENT (:STATE STATE :X X :Y Y :X-REL X-REL :Y-REL Y-REL)  
    ...)  
 (:MOUSE-BUTTON-DOWN-EVENT (:BUTTON BUTTON :STATE STATE :X X :Y Y)  
    ...)  
 (:MOUSE-BUTTON-UP-EVENT (:BUTTON BUTTON :STATE STATE :X X :Y Y)  
    ...)  
 (:JOY-AXIS-MOTION-EVENT (:WHICH WHICH :AXIS AXIS :VALUE VALUE)  
    ...)  
 (:JOY-BUTTON-DOWN-EVENT (:WHICH WHICH :BUTTON BUTTON :STATE STATE)  
    ...)  
 (:JOY-BUTTON-UP-EVENT (:WHICH WHICH :BUTTON BUTTON :STATE STATE)  
    ...)  
 (:JOY-HAT-MOTION-EVENT (:WHICH WHICH :HAT HAT :VALUE VALUE)  
    ...)  
 (:JOY-BALL-MOTION-EVENT (:WHICH WHICH :BALL BALL :X-REL X-REL :Y-REL Y-REL)  
    ...)  
 (:VIDEO-RESIZE-EVENT (:W W :H H)  
    ...)  
 (:VIDEO-EXPOSE-EVENT ()  
    ...)  
 (:SYS-WM-EVENT ()  
    ...)  
 (:USER-EVENT (:TYPE TYPE :CODE CODE :DATA1 DATA1 :DATA2 DATA2)  
    ...)  
 (:QUIT-EVENT ()  
    ...  
    T)  
 (:IDLE ()  
    ... )) </code></pre>

</blockquote>

<!-- End of entry for WITH-EVENTS -->


<!-- Entry for WITH-FONT -->

<p><br>[Macro]<br><a class=none name='with-font'><b>with-font</b> <i>(font font-definition) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Sets <code>*DEFAULT-FONT*</code> to a new <a href="#bitmap-font">BITMAP-FONT</a> in <code>FONT</code> within the scope of <code>WITH-FONT</code>. Frees <code>FONT</code> when <code>WITH-FONT</code> goes out of scope, and sets <code>*DEFAULT-FONT* to </code>NIL. </p><h5>Example</h5><pre><code>(WITH-FONT (new-font *font-8x8*)  
    (DRAW-CHARACTER-SHADED-* &quot;Hello World!&quot; 0 0 F-COLOR B-COLOR)) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for WITH-FONT -->


<!-- Entry for WITH-FOREIGN-COLOR-COPY -->

<p><br>[Macro]<br><a class=none name='with-foreign-color-copy'><b>with-foreign-color-copy</b> <i>(struct color) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Creates and assigns a new foreign <code>SDL_Color</code> to <code>STRUCT</code>. Then copies the color components from <code>COLOR</code> into <code>STRUCT</code>. <code>STRUCT</code> is free&#039;d when out of scope. </p>

</blockquote>

<!-- End of entry for WITH-FOREIGN-COLOR-COPY -->


<!-- Entry for WITH-INIT -->

<p><br>[Macro]<br><a class=none name='with-init'><b>with-init</b> <i>flags declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p><code>WITH-INIT</code> is a convenience macro that will attempt to initialise the SDL library and SDL subsystems prior to executing the forms in <code>BODY</code>. Upon exit <code>WITH-INIT</code> will uninitialize the SDL library and SDL subsystems. </p><p>The lispbuilder-sdl initialization routines are somewhat complicated by the fact that a Lisp development environment will load a foreign library once but then initialise and uninitialise the library multiple times. A C/C++ development environment will open and then close a library after each execution, freeing all resources left hanging by incomplete or buggy uninitialise functions. C libraries may therefore frequently core dump in a Lisp environment when resources are not feed properly prior to the library being reinitialized. </p><p>LISPBUILDER-SDL provides functionality affording the programmer a finer granularity of control of the initialisation/uninitialisation of foreign libraries. The fuctions that provide these capabilities are as follows: </p><ul><li><a href="#initialize-on-startup">INITIALIZE-ON-STARTUP</a></li><li><a href="#quit-on-exit">QUIT-ON-EXIT</a></li><li><a href="#list-sub-systems">LIST-SUB-SYSTEMS</a></li><li><a href="#return-sub-systems-of-status">RETURN-SUB-SYSTEMS-OF-STATUS</a></li><li><a href="#init-sub-systems">INIT-SUB-SYSTEMS</a></li><li><a href="#quit-sub-systems">QUIT-SUB-SYSTEMS</a></li><li><a href="#init-sdl">INIT-SDL</a></li><li><a href="#quit-sdl">QUIT-SDL</a></li></ul><h5>Defaults</h5><ul><li>By default <code>WITH-INIT</code> will only initialise the <code>SDL-INIT-VIDEO</code> SDL subsystem. Additional SDL subsystems can be initialized by calling <a href="#initialize-on-startup">INITIALIZE-ON-STARTUP</a>. </li><li>By default <code>WITH-INIT</code> will only uninitialise the <code>SDL-INIT-VIDEO</code> SDL subsystem. Additional SDL subsystems can be uninitialized by calling <a href="#quit-on-exit">QUIT-ON-EXIT</a>. </li></ul><h6>Initialisation/Uninitialisation of the SDL library</h6><p>The SDL library is initialised only: </p><ul><li>If the library is not yet already initialized, or</li><li><a href="#sdl-init-on-startup">SDL-INIT-ON-STARTUP</a> is <code>T</code>.</li></ul><p>The SDL library is uninitialised only: </p><ul><li>When <a href="#sdl-quit-on-exit">SDL-QUIT-ON-EXIT</a> is <code>T</code>.</li></ul><h6>Initialisation/Uninitialisation of external libraries</h6><p>Hooks are provided to allow external libraries to be initialized or uninitialised automatically following the initialisation or uninitialisation of the SDL library. </p><p>To initialise an external library, push a function that initialises the external library onto <code>*EXTERNAL-INIT-ON-STARTUP*</code>. The function must take no arguments. For example: </p><pre><code>(defun init-ttf ()  
   (if (is-init)  
     t  
     (sdl-ttf-cffi::ttf-init)))  
(pushnew &#039;init-ttf sdl:*external-init-on-startup*) </code></pre><p>To uninitialise an external library, push a function that uninitialises the external library onto  <code>*EXTERNAL-QUIT-ON-EXIT*</code>. The function must take no arguments. For example: </p><pre><code>(defun quit-ttf ()  
   (if (is-init)  
     (sdl-ttf-cffi::ttf-quit)))  
(pushnew &#039;quit-ttf sdl:*external-quit-on-exit*) </code></pre><h5>Parameters</h5><ul><li><code>FLAGS</code> may be one or more of: <code>SDL-INIT-EVERYTHING</code>, <code>SDL-INIT-VIDEO</code>, <code>SDL-INIT-CDROM</code>, <code>SDL-INIT-AUDIO</code>, <code>SDL-INIT-TIMER</code>, <code>SDL-INIT-JOYSTICK</code>, <code>SDL-INIT-EVENTTHREAD</code> and <code>SDL-INIT-NOPARACHUTE</code>. <em>Note</em>: When <code>FLAGS</code> is set by <code>WITH-INIT</code>, subsequent calls to <a href="#initialize-on-startup">INITIALIZE-ON-STARTUP</a> and <a href="#quit-on-exit">QUIT-ON-EXIT</a> are ignored. <code>WITH-INIT</code> will only initialize and uninitialize the subsytems specified in <code>FLAGS</code>. </li></ul><h5>Example</h5><pre><code>(with-init (SDL-INIT-VIDEO SDL-INIT-CDROM SDL-INIT-AUDIO)  
  ....)  
 
(with-init ()  
  (INITIALIZE-ON-STARTUP SDL-INIT-VIDEO SDL-INIT-CDROM SDL-INIT-AUDIO)  
  (QUIT-ON-EXIT SDL-INIT-VIDEO SDL-INIT-CDROM SDL-INIT-AUDIO)  
  ....) </code></pre>

</blockquote>

<!-- End of entry for WITH-INIT -->


<!-- Entry for WITH-LOCKED-SURFACE -->

<p><br>[Macro]<br><a class=none name='with-locked-surface'><b>with-locked-surface</b> <i>(var <tt>&amp;optional</tt> surface) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WITH-LOCKED-SURFACE -->


<!-- Entry for WITH-LOCKED-SURFACES -->

<p><br>[Macro]<br><a class=none name='with-locked-surfaces'><b>with-locked-surfaces</b> <i>bindings <tt>&amp;rest</tt> body</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WITH-LOCKED-SURFACES -->


<!-- Entry for WITH-POINT -->

<p><br>[Macro]<br><a class=none name='with-point'><b>with-point</b> <i>(var <tt>&amp;optional</tt> point) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>A convenience macro that binds <code>*DEFAULT-POINT*</code> to <code>VAR</code> within the scope of <code>WITH-POINT</code>. <code>VAR</code> must be of type <code>POINT</code>. If <code>POINT</code> is not <code>NIL</code>, then <code>VAR is set to </code>POINT`. </p>

</blockquote>

<!-- End of entry for WITH-POINT -->


<!-- Entry for WITH-RECTANGLE -->

<p><br>[Macro]<br><a class=none name='with-rectangle'><b>with-rectangle</b> <i>(var <tt>&amp;optional</tt> rectangle free) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>A convenience macro that binds <code>*DEFAULT-RECTANGLE*</code> to <code>VAR</code> within the scope of <code>WITH-RECTANGLE</code>. <code>VAR</code> must be of type <code>RECTANGLE</code>. <code>VAR</code> is set to <code>RECTANGLE</code> when <code>RECTANGLE</code> is not <code>NIL</code>. <code>VAR</code> is freed when <code>FREE</code> is <code>T</code>. </p><h5>Example</h5><pre><code>(WITH-RECTANGLE (a-rect (RECTANGLE :x 0 :y 0 :w 100 :h 100))  
    ...) </code></pre>

</blockquote>

<!-- End of entry for WITH-RECTANGLE -->


<!-- Entry for WITH-RECTANGLES -->

<p><br>[Macro]<br><a class=none name='with-rectangles'><b>with-rectangles</b> <i>bindings declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>A convenience macro that binds multiple rectangles as per <a href="#with-rectangle">WITH-RECTANGLE</a>. </p><h5>Example</h5><pre><code>(WITH-RECTANGLES ((a-rect (RECTANGLE :x 0 :y 0 :w 100 :h 100))  
                  ((b-rect (RECTANGLE :x 0 :y 100 :w 100 :h 100))  
                  ((c-rect (RECTANGLE :x 0 :y 200 :w 100 :h 100)))  
    ...) </code></pre>

</blockquote>

<!-- End of entry for WITH-RECTANGLES -->


<!-- Entry for WITH-SHAPE -->

<p><br>[Macro]<br><a class=none name='with-shape'><b>with-shape</b> <i>(<tt>&amp;optional</tt> style) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Draw a polygon of <code>*DEFAULT-COLOR*</code> to <code>*DEFAULT-SURFACE*</code>. </p><h5>Local Methods</h5><p>A vertex may be added using: </p><ul><li><code>ADD-VERTEX</code> which accepts an <code>SDL:POINT</code>, or</li><li><code>ADD-VERTEX-*</code> which is the x/y spread version</li></ul><p>ADD-VERTEX and ADD-VERTEX-* are valid only within the scop of WITH-SHAPE. </p><h5>Parameters</h5><ul><li><code>STYLE</code> describes the line style used to draw the shape and may be one of <code>:SOLID</code>, <code>:DASH</code>, or <code>:POINTS</code>. Use <code>:SOLID</code> to draw a single continuous line through the specified waypoints. Use <code>:DASH</code> to draw a line between alternate waypoint pairs. Use <code>:POINTS</code> to draw a single pixel at each waypoint. </li></ul><h5>Example</h5><pre><code>(SDL:WITH-COLOR (COL (SDL:COLOR))  
   (WITH-SHAPE (:POINTS)  
     (ADD-VERTEX-* 60  40)  
     (ADD-VERTEX-* 160 10)  
     (ADD-VERTEX-* 170 150)  
     (ADD-VERTEX-* 60  150))) </code></pre><h5>Packages</h5><ul><li>Also supported in <em>LISPBUILDER-SDL-GFX</em></li></ul>

</blockquote>

<!-- End of entry for WITH-SHAPE -->


<!-- Entry for WITH-SURFACE -->

<p><br>[Macro]<br><a class=none name='with-surface'><b>with-surface</b> <i>(var <tt>&amp;optional</tt> surface free) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WITH-SURFACE -->


<!-- Entry for WITH-SURFACE-SLOTS -->

<p><br>[Macro]<br><a class=none name='with-surface-slots'><b>with-surface-slots</b> <i>(var <tt>&amp;optional</tt> surface) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WITH-SURFACE-SLOTS -->


<!-- Entry for WITH-SURFACES -->

<p><br>[Macro]<br><a class=none name='with-surfaces'><b>with-surfaces</b> <i>bindings <tt>&amp;rest</tt> body</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for WITH-SURFACES -->


<!-- Entry for WITHIN-RANGE -->

<p><br>[Function]<br><a class=none name='within-range'><b>within-range</b> <i>p1 p2 distance</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns true <code>T</code>, if the distance between the <code>POINT</code>s <code>P1</code> <code>P2</code> is &lt;= the distance <code>DISTANCE</code>. </p>

</blockquote>

<!-- End of entry for WITHIN-RANGE -->


<!-- Entry for WITHIN-RANGE-* -->

<p><br>[Function]<br><a class=none name='within-range-*'><b>within-range-*</b> <i>x1 y1 x2 y2 distance</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns true <code>T</code>, if the distance between the coordinates <code>X1</code>, <code>Y1</code> and <code>X2</code>, <code>Y2</code> is &lt;= the distance <code>DISTANCE</code>. </p>

</blockquote>

<!-- End of entry for WITHIN-RANGE-* -->


<!-- Entry for X -->

<p><br>[Generic accessor]<br><a class=none name='x'><b>x</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for X -->


<!-- Entry for X -->

<p><br>[Specialized accessor]<br><a class=none><b>x</b> <i>(obj font)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x</b> <i>(obj font)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for X -->


<!-- Entry for X -->

<p><br>[Specialized accessor]<br><a class=none><b>x</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x</b> <i>(obj sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>X</code> position coordinate of <code>SURFACE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for X -->


<!-- Entry for X -->

<p><br>[Specialized accessor]<br><a class=none><b>x</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>X</code> position coordinate of the rectangle <code>RECTANGLE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for X -->


<!-- Entry for X -->

<p><br>[Specialized accessor]<br><a class=none><b>x</b> <i>(obj vector)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x</b> <i>(obj vector)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>X</code> coordindate of the point <code>POINT</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for X -->


<!-- Entry for X2 -->

<p><br>[Generic accessor]<br><a class=none name='x2'><b>x2</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x2</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for X2 -->


<!-- Entry for X2 -->

<p><br>[Specialized accessor]<br><a class=none><b>x2</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>x2</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Sets the WIDTH of the rectangle <code>RECTANGLE</code> to <code>(- X2 X)</code> </p>

</blockquote>

<!-- End of entry for X2 -->


<!-- Entry for Y -->

<p><br>[Generic accessor]<br><a class=none name='y'><b>y</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for Y -->


<!-- Entry for Y -->

<p><br>[Specialized accessor]<br><a class=none><b>y</b> <i>(obj font)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y</b> <i>(obj font)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for Y -->


<!-- Entry for Y -->

<p><br>[Specialized accessor]<br><a class=none><b>y</b> <i>(obj sdl-surface)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y</b> <i>(obj sdl-surface)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>Y</code> position coordinate of <code>SURFACE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for Y -->


<!-- Entry for Y -->

<p><br>[Specialized accessor]<br><a class=none><b>y</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>Y</code> position coordinate of the rectangle <code>RECTANGLE</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for Y -->


<!-- Entry for Y -->

<p><br>[Specialized accessor]<br><a class=none><b>y</b> <i>(obj vector)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y</b> <i>(obj vector)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns the <code>Y</code> coordindate of the point <code>POINT</code> as an <code>INTEGER</code>. </p>

</blockquote>

<!-- End of entry for Y -->


<!-- Entry for Y2 -->

<p><br>[Generic accessor]<br><a class=none name='y2'><b>y2</b> <i>obj</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y2</b> <i>obj</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>



</blockquote>

<!-- End of entry for Y2 -->


<!-- Entry for Y2 -->

<p><br>[Specialized accessor]<br><a class=none><b>y2</b> <i>(obj rectangle)</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>y2</b> <i>(obj rectangle)</i><tt>)</tt> <i>value</i><tt>)</tt></a>
<blockquote><br>

<p>Returns <code>(+ Y HEIGHT)</code> of the rectangle <code>RECTANGLE</code>. </p>

</blockquote>

<!-- End of entry for Y2 -->


<!-- Entry for ZOOM-SURFACE -->

<p><br>[Function]<br><a class=none name='zoom-surface'><b>zoom-surface</b> <i>zoomx zoomy <tt>&amp;key</tt> surface free smooth</i> =&gt; <i>result</i></a>
<blockquote><br>

<p>Returns a new <a href="#surface">SURFACE</a> scaled to <code>ZOOMX</code> and <code>ZOOMY</code>. </p><h5>Parameters</h5><ul><li><code>:ZOOMX</code> and <code>ZOOMY</code> are the scaling factors. A negative scaling factor will flip the corresponding axis. <em>Note</em>: Flipping is only supported with anti-aliasing turned off. </li><li><code>:SURFACE</code> is the surface to rotate <a href="#surface">SURFACE</a>.</li><li><code>:FREE</code> when <code>T</code> will free <code>SURFACE</code>.</li><li><code>:SMOOTH</code> when <code>T</code> will anti-aliase the new surface.</li></ul><h5>Packages</h5><ul><li>Supported in <em>LISPBUILDER-SDL-GFX</em></li><li><em>LISPBUILDER-SDL-GFX</em> ignores <code>:FREE</code>.</li></ul>

</blockquote>

<!-- End of entry for ZOOM-SURFACE -->


<br>&nbsp;<br><h3><a class=none name="ack">Acknowledgements</a></h3>

<p>
This documentation was prepared with <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>.
</p>
<p>
$Header: /usr/local/cvsrep/documentation-template/output.lisp,v 1.14 2008/05/29 08:23:37 edi Exp $
<p><a href="http://weitz.de/index.html">BACK TO MY HOMEPAGE</a>

</body>
</html>